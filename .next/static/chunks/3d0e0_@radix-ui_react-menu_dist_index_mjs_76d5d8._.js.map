{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@radix-ui+react-menu@2.1.1_@types+react-dom@18.3.0_@types+react@18.3.4_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@radix-ui/react-menu/src/Menu.tsx"],"sourcesContent":["import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs, composeRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useDirection } from '@radix-ui/react-direction';\nimport { DismissableLayer } from '@radix-ui/react-dismissable-layer';\nimport { useFocusGuards } from '@radix-ui/react-focus-guards';\nimport { FocusScope } from '@radix-ui/react-focus-scope';\nimport { useId } from '@radix-ui/react-id';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { createPopperScope } from '@radix-ui/react-popper';\nimport { Portal as PortalPrimitive } from '@radix-ui/react-portal';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive, dispatchDiscreteCustomEvent } from '@radix-ui/react-primitive';\nimport * as RovingFocusGroup from '@radix-ui/react-roving-focus';\nimport { createRovingFocusGroupScope } from '@radix-ui/react-roving-focus';\nimport { Slot } from '@radix-ui/react-slot';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { hideOthers } from 'aria-hidden';\nimport { RemoveScroll } from 'react-remove-scroll';\n\nimport type { Scope } from '@radix-ui/react-context';\n\ntype Direction = 'ltr' | 'rtl';\n\nconst SELECTION_KEYS = ['Enter', ' '];\nconst FIRST_KEYS = ['ArrowDown', 'PageUp', 'Home'];\nconst LAST_KEYS = ['ArrowUp', 'PageDown', 'End'];\nconst FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];\nconst SUB_OPEN_KEYS: Record<Direction, string[]> = {\n  ltr: [...SELECTION_KEYS, 'ArrowRight'],\n  rtl: [...SELECTION_KEYS, 'ArrowLeft'],\n};\nconst SUB_CLOSE_KEYS: Record<Direction, string[]> = {\n  ltr: ['ArrowLeft'],\n  rtl: ['ArrowRight'],\n};\n\n/* -------------------------------------------------------------------------------------------------\n * Menu\n * -----------------------------------------------------------------------------------------------*/\n\nconst MENU_NAME = 'Menu';\n\ntype ItemData = { disabled: boolean; textValue: string };\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  MenuItemElement,\n  ItemData\n>(MENU_NAME);\n\ntype ScopedProps<P> = P & { __scopeMenu?: Scope };\nconst [createMenuContext, createMenuScope] = createContextScope(MENU_NAME, [\n  createCollectionScope,\n  createPopperScope,\n  createRovingFocusGroupScope,\n]);\nconst usePopperScope = createPopperScope();\nconst useRovingFocusGroupScope = createRovingFocusGroupScope();\n\ntype MenuContextValue = {\n  open: boolean;\n  onOpenChange(open: boolean): void;\n  content: MenuContentElement | null;\n  onContentChange(content: MenuContentElement | null): void;\n};\n\nconst [MenuProvider, useMenuContext] = createMenuContext<MenuContextValue>(MENU_NAME);\n\ntype MenuRootContextValue = {\n  onClose(): void;\n  isUsingKeyboardRef: React.RefObject<boolean>;\n  dir: Direction;\n  modal: boolean;\n};\n\nconst [MenuRootProvider, useMenuRootContext] = createMenuContext<MenuRootContextValue>(MENU_NAME);\n\ninterface MenuProps {\n  children?: React.ReactNode;\n  open?: boolean;\n  onOpenChange?(open: boolean): void;\n  dir?: Direction;\n  modal?: boolean;\n}\n\nconst Menu: React.FC<MenuProps> = (props: ScopedProps<MenuProps>) => {\n  const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props;\n  const popperScope = usePopperScope(__scopeMenu);\n  const [content, setContent] = React.useState<MenuContentElement | null>(null);\n  const isUsingKeyboardRef = React.useRef(false);\n  const handleOpenChange = useCallbackRef(onOpenChange);\n  const direction = useDirection(dir);\n\n  React.useEffect(() => {\n    // Capture phase ensures we set the boolean before any side effects execute\n    // in response to the key or pointer event as they might depend on this value.\n    const handleKeyDown = () => {\n      isUsingKeyboardRef.current = true;\n      document.addEventListener('pointerdown', handlePointer, { capture: true, once: true });\n      document.addEventListener('pointermove', handlePointer, { capture: true, once: true });\n    };\n    const handlePointer = () => (isUsingKeyboardRef.current = false);\n    document.addEventListener('keydown', handleKeyDown, { capture: true });\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown, { capture: true });\n      document.removeEventListener('pointerdown', handlePointer, { capture: true });\n      document.removeEventListener('pointermove', handlePointer, { capture: true });\n    };\n  }, []);\n\n  return (\n    <PopperPrimitive.Root {...popperScope}>\n      <MenuProvider\n        scope={__scopeMenu}\n        open={open}\n        onOpenChange={handleOpenChange}\n        content={content}\n        onContentChange={setContent}\n      >\n        <MenuRootProvider\n          scope={__scopeMenu}\n          onClose={React.useCallback(() => handleOpenChange(false), [handleOpenChange])}\n          isUsingKeyboardRef={isUsingKeyboardRef}\n          dir={direction}\n          modal={modal}\n        >\n          {children}\n        </MenuRootProvider>\n      </MenuProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nMenu.displayName = MENU_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuAnchor\n * -----------------------------------------------------------------------------------------------*/\n\nconst ANCHOR_NAME = 'MenuAnchor';\n\ntype MenuAnchorElement = React.ElementRef<typeof PopperPrimitive.Anchor>;\ntype PopperAnchorProps = React.ComponentPropsWithoutRef<typeof PopperPrimitive.Anchor>;\ninterface MenuAnchorProps extends PopperAnchorProps {}\n\nconst MenuAnchor = React.forwardRef<MenuAnchorElement, MenuAnchorProps>(\n  (props: ScopedProps<MenuAnchorProps>, forwardedRef) => {\n    const { __scopeMenu, ...anchorProps } = props;\n    const popperScope = usePopperScope(__scopeMenu);\n    return <PopperPrimitive.Anchor {...popperScope} {...anchorProps} ref={forwardedRef} />;\n  }\n);\n\nMenuAnchor.displayName = ANCHOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuPortal\n * -----------------------------------------------------------------------------------------------*/\n\nconst PORTAL_NAME = 'MenuPortal';\n\ntype PortalContextValue = { forceMount?: true };\nconst [PortalProvider, usePortalContext] = createMenuContext<PortalContextValue>(PORTAL_NAME, {\n  forceMount: undefined,\n});\n\ntype PortalProps = React.ComponentPropsWithoutRef<typeof PortalPrimitive>;\ninterface MenuPortalProps {\n  children?: React.ReactNode;\n  /**\n   * Specify a container element to portal the content into.\n   */\n  container?: PortalProps['container'];\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuPortal: React.FC<MenuPortalProps> = (props: ScopedProps<MenuPortalProps>) => {\n  const { __scopeMenu, forceMount, children, container } = props;\n  const context = useMenuContext(PORTAL_NAME, __scopeMenu);\n  return (\n    <PortalProvider scope={__scopeMenu} forceMount={forceMount}>\n      <Presence present={forceMount || context.open}>\n        <PortalPrimitive asChild container={container}>\n          {children}\n        </PortalPrimitive>\n      </Presence>\n    </PortalProvider>\n  );\n};\n\nMenuPortal.displayName = PORTAL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'MenuContent';\n\ntype MenuContentContextValue = {\n  onItemEnter(event: React.PointerEvent): void;\n  onItemLeave(event: React.PointerEvent): void;\n  onTriggerLeave(event: React.PointerEvent): void;\n  searchRef: React.RefObject<string>;\n  pointerGraceTimerRef: React.MutableRefObject<number>;\n  onPointerGraceIntentChange(intent: GraceIntent | null): void;\n};\nconst [MenuContentProvider, useMenuContentContext] =\n  createMenuContext<MenuContentContextValue>(CONTENT_NAME);\n\ntype MenuContentElement = MenuRootContentTypeElement;\n/**\n * We purposefully don't union MenuRootContent and MenuSubContent props here because\n * they have conflicting prop types. We agreed that we would allow MenuSubContent to\n * accept props that it would just ignore.\n */\ninterface MenuContentProps extends MenuRootContentTypeProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuContent = React.forwardRef<MenuContentElement, MenuContentProps>(\n  (props: ScopedProps<MenuContentProps>, forwardedRef) => {\n    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeMenu);\n    const { forceMount = portalContext.forceMount, ...contentProps } = props;\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    const rootContext = useMenuRootContext(CONTENT_NAME, props.__scopeMenu);\n\n    return (\n      <Collection.Provider scope={props.__scopeMenu}>\n        <Presence present={forceMount || context.open}>\n          <Collection.Slot scope={props.__scopeMenu}>\n            {rootContext.modal ? (\n              <MenuRootContentModal {...contentProps} ref={forwardedRef} />\n            ) : (\n              <MenuRootContentNonModal {...contentProps} ref={forwardedRef} />\n            )}\n          </Collection.Slot>\n        </Presence>\n      </Collection.Provider>\n    );\n  }\n);\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuRootContentTypeElement = MenuContentImplElement;\ninterface MenuRootContentTypeProps\n  extends Omit<MenuContentImplProps, keyof MenuContentImplPrivateProps> {}\n\nconst MenuRootContentModal = React.forwardRef<MenuRootContentTypeElement, MenuRootContentTypeProps>(\n  (props: ScopedProps<MenuRootContentTypeProps>, forwardedRef) => {\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    const ref = React.useRef<MenuRootContentTypeElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n\n    // Hide everything from ARIA except the `MenuContent`\n    React.useEffect(() => {\n      const content = ref.current;\n      if (content) return hideOthers(content);\n    }, []);\n\n    return (\n      <MenuContentImpl\n        {...props}\n        ref={composedRefs}\n        // we make sure we're not trapping once it's been closed\n        // (closed !== unmounted when animating out)\n        trapFocus={context.open}\n        // make sure to only disable pointer events when open\n        // this avoids blocking interactions while animating out\n        disableOutsidePointerEvents={context.open}\n        disableOutsideScroll\n        // When focus is trapped, a `focusout` event may still happen.\n        // We make sure we don't trigger our `onDismiss` in such case.\n        onFocusOutside={composeEventHandlers(\n          props.onFocusOutside,\n          (event) => event.preventDefault(),\n          { checkForDefaultPrevented: false }\n        )}\n        onDismiss={() => context.onOpenChange(false)}\n      />\n    );\n  }\n);\n\nconst MenuRootContentNonModal = React.forwardRef<\n  MenuRootContentTypeElement,\n  MenuRootContentTypeProps\n>((props: ScopedProps<MenuRootContentTypeProps>, forwardedRef) => {\n  const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n  return (\n    <MenuContentImpl\n      {...props}\n      ref={forwardedRef}\n      trapFocus={false}\n      disableOutsidePointerEvents={false}\n      disableOutsideScroll={false}\n      onDismiss={() => context.onOpenChange(false)}\n    />\n  );\n});\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuContentImplElement = React.ElementRef<typeof PopperPrimitive.Content>;\ntype FocusScopeProps = React.ComponentPropsWithoutRef<typeof FocusScope>;\ntype DismissableLayerProps = React.ComponentPropsWithoutRef<typeof DismissableLayer>;\ntype RovingFocusGroupProps = React.ComponentPropsWithoutRef<typeof RovingFocusGroup.Root>;\ntype PopperContentProps = React.ComponentPropsWithoutRef<typeof PopperPrimitive.Content>;\ntype MenuContentImplPrivateProps = {\n  onOpenAutoFocus?: FocusScopeProps['onMountAutoFocus'];\n  onDismiss?: DismissableLayerProps['onDismiss'];\n  disableOutsidePointerEvents?: DismissableLayerProps['disableOutsidePointerEvents'];\n\n  /**\n   * Whether scrolling outside the `MenuContent` should be prevented\n   * (default: `false`)\n   */\n  disableOutsideScroll?: boolean;\n\n  /**\n   * Whether focus should be trapped within the `MenuContent`\n   * (default: false)\n   */\n  trapFocus?: FocusScopeProps['trapped'];\n};\ninterface MenuContentImplProps\n  extends MenuContentImplPrivateProps,\n    Omit<PopperContentProps, 'dir' | 'onPlaced'> {\n  /**\n   * Event handler called when auto-focusing on close.\n   * Can be prevented.\n   */\n  onCloseAutoFocus?: FocusScopeProps['onUnmountAutoFocus'];\n\n  /**\n   * Whether keyboard navigation should loop around\n   * @defaultValue false\n   */\n  loop?: RovingFocusGroupProps['loop'];\n\n  onEntryFocus?: RovingFocusGroupProps['onEntryFocus'];\n  onEscapeKeyDown?: DismissableLayerProps['onEscapeKeyDown'];\n  onPointerDownOutside?: DismissableLayerProps['onPointerDownOutside'];\n  onFocusOutside?: DismissableLayerProps['onFocusOutside'];\n  onInteractOutside?: DismissableLayerProps['onInteractOutside'];\n}\n\nconst MenuContentImpl = React.forwardRef<MenuContentImplElement, MenuContentImplProps>(\n  (props: ScopedProps<MenuContentImplProps>, forwardedRef) => {\n    const {\n      __scopeMenu,\n      loop = false,\n      trapFocus,\n      onOpenAutoFocus,\n      onCloseAutoFocus,\n      disableOutsidePointerEvents,\n      onEntryFocus,\n      onEscapeKeyDown,\n      onPointerDownOutside,\n      onFocusOutside,\n      onInteractOutside,\n      onDismiss,\n      disableOutsideScroll,\n      ...contentProps\n    } = props;\n    const context = useMenuContext(CONTENT_NAME, __scopeMenu);\n    const rootContext = useMenuRootContext(CONTENT_NAME, __scopeMenu);\n    const popperScope = usePopperScope(__scopeMenu);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);\n    const getItems = useCollection(__scopeMenu);\n    const [currentItemId, setCurrentItemId] = React.useState<string | null>(null);\n    const contentRef = React.useRef<HTMLDivElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, contentRef, context.onContentChange);\n    const timerRef = React.useRef(0);\n    const searchRef = React.useRef('');\n    const pointerGraceTimerRef = React.useRef(0);\n    const pointerGraceIntentRef = React.useRef<GraceIntent | null>(null);\n    const pointerDirRef = React.useRef<Side>('right');\n    const lastPointerXRef = React.useRef(0);\n\n    const ScrollLockWrapper = disableOutsideScroll ? RemoveScroll : React.Fragment;\n    const scrollLockWrapperProps = disableOutsideScroll\n      ? { as: Slot, allowPinchZoom: true }\n      : undefined;\n\n    const handleTypeaheadSearch = (key: string) => {\n      const search = searchRef.current + key;\n      const items = getItems().filter((item) => !item.disabled);\n      const currentItem = document.activeElement;\n      const currentMatch = items.find((item) => item.ref.current === currentItem)?.textValue;\n      const values = items.map((item) => item.textValue);\n      const nextMatch = getNextMatch(values, search, currentMatch);\n      const newItem = items.find((item) => item.textValue === nextMatch)?.ref.current;\n\n      // Reset `searchRef` 1 second after it was last updated\n      (function updateSearch(value: string) {\n        searchRef.current = value;\n        window.clearTimeout(timerRef.current);\n        if (value !== '') timerRef.current = window.setTimeout(() => updateSearch(''), 1000);\n      })(search);\n\n      if (newItem) {\n        /**\n         * Imperative focus during keydown is risky so we prevent React's batching updates\n         * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n         */\n        setTimeout(() => (newItem as HTMLElement).focus());\n      }\n    };\n\n    React.useEffect(() => {\n      return () => window.clearTimeout(timerRef.current);\n    }, []);\n\n    // Make sure the whole tree has focus guards as our `MenuContent` may be\n    // the last element in the DOM (beacuse of the `Portal`)\n    useFocusGuards();\n\n    const isPointerMovingToSubmenu = React.useCallback((event: React.PointerEvent) => {\n      const isMovingTowards = pointerDirRef.current === pointerGraceIntentRef.current?.side;\n      return isMovingTowards && isPointerInGraceArea(event, pointerGraceIntentRef.current?.area);\n    }, []);\n\n    return (\n      <MenuContentProvider\n        scope={__scopeMenu}\n        searchRef={searchRef}\n        onItemEnter={React.useCallback(\n          (event) => {\n            if (isPointerMovingToSubmenu(event)) event.preventDefault();\n          },\n          [isPointerMovingToSubmenu]\n        )}\n        onItemLeave={React.useCallback(\n          (event) => {\n            if (isPointerMovingToSubmenu(event)) return;\n            contentRef.current?.focus();\n            setCurrentItemId(null);\n          },\n          [isPointerMovingToSubmenu]\n        )}\n        onTriggerLeave={React.useCallback(\n          (event) => {\n            if (isPointerMovingToSubmenu(event)) event.preventDefault();\n          },\n          [isPointerMovingToSubmenu]\n        )}\n        pointerGraceTimerRef={pointerGraceTimerRef}\n        onPointerGraceIntentChange={React.useCallback((intent) => {\n          pointerGraceIntentRef.current = intent;\n        }, [])}\n      >\n        <ScrollLockWrapper {...scrollLockWrapperProps}>\n          <FocusScope\n            asChild\n            trapped={trapFocus}\n            onMountAutoFocus={composeEventHandlers(onOpenAutoFocus, (event) => {\n              // when opening, explicitly focus the content area only and leave\n              // `onEntryFocus` in  control of focusing first item\n              event.preventDefault();\n              contentRef.current?.focus({ preventScroll: true });\n            })}\n            onUnmountAutoFocus={onCloseAutoFocus}\n          >\n            <DismissableLayer\n              asChild\n              disableOutsidePointerEvents={disableOutsidePointerEvents}\n              onEscapeKeyDown={onEscapeKeyDown}\n              onPointerDownOutside={onPointerDownOutside}\n              onFocusOutside={onFocusOutside}\n              onInteractOutside={onInteractOutside}\n              onDismiss={onDismiss}\n            >\n              <RovingFocusGroup.Root\n                asChild\n                {...rovingFocusGroupScope}\n                dir={rootContext.dir}\n                orientation=\"vertical\"\n                loop={loop}\n                currentTabStopId={currentItemId}\n                onCurrentTabStopIdChange={setCurrentItemId}\n                onEntryFocus={composeEventHandlers(onEntryFocus, (event) => {\n                  // only focus first item when using keyboard\n                  if (!rootContext.isUsingKeyboardRef.current) event.preventDefault();\n                })}\n                preventScrollOnEntryFocus\n              >\n                <PopperPrimitive.Content\n                  role=\"menu\"\n                  aria-orientation=\"vertical\"\n                  data-state={getOpenState(context.open)}\n                  data-radix-menu-content=\"\"\n                  dir={rootContext.dir}\n                  {...popperScope}\n                  {...contentProps}\n                  ref={composedRefs}\n                  style={{ outline: 'none', ...contentProps.style }}\n                  onKeyDown={composeEventHandlers(contentProps.onKeyDown, (event) => {\n                    // submenu key events bubble through portals. We only care about keys in this menu.\n                    const target = event.target as HTMLElement;\n                    const isKeyDownInside =\n                      target.closest('[data-radix-menu-content]') === event.currentTarget;\n                    const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;\n                    const isCharacterKey = event.key.length === 1;\n                    if (isKeyDownInside) {\n                      // menus should not be navigated using tab key so we prevent it\n                      if (event.key === 'Tab') event.preventDefault();\n                      if (!isModifierKey && isCharacterKey) handleTypeaheadSearch(event.key);\n                    }\n                    // focus first/last item based on key pressed\n                    const content = contentRef.current;\n                    if (event.target !== content) return;\n                    if (!FIRST_LAST_KEYS.includes(event.key)) return;\n                    event.preventDefault();\n                    const items = getItems().filter((item) => !item.disabled);\n                    const candidateNodes = items.map((item) => item.ref.current!);\n                    if (LAST_KEYS.includes(event.key)) candidateNodes.reverse();\n                    focusFirst(candidateNodes);\n                  })}\n                  onBlur={composeEventHandlers(props.onBlur, (event) => {\n                    // clear search buffer when leaving the menu\n                    if (!event.currentTarget.contains(event.target)) {\n                      window.clearTimeout(timerRef.current);\n                      searchRef.current = '';\n                    }\n                  })}\n                  onPointerMove={composeEventHandlers(\n                    props.onPointerMove,\n                    whenMouse((event) => {\n                      const target = event.target as HTMLElement;\n                      const pointerXHasChanged = lastPointerXRef.current !== event.clientX;\n\n                      // We don't use `event.movementX` for this check because Safari will\n                      // always return `0` on a pointer event.\n                      if (event.currentTarget.contains(target) && pointerXHasChanged) {\n                        const newDir = event.clientX > lastPointerXRef.current ? 'right' : 'left';\n                        pointerDirRef.current = newDir;\n                        lastPointerXRef.current = event.clientX;\n                      }\n                    })\n                  )}\n                />\n              </RovingFocusGroup.Root>\n            </DismissableLayer>\n          </FocusScope>\n        </ScrollLockWrapper>\n      </MenuContentProvider>\n    );\n  }\n);\n\nMenuContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'MenuGroup';\n\ntype MenuGroupElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface MenuGroupProps extends PrimitiveDivProps {}\n\nconst MenuGroup = React.forwardRef<MenuGroupElement, MenuGroupProps>(\n  (props: ScopedProps<MenuGroupProps>, forwardedRef) => {\n    const { __scopeMenu, ...groupProps } = props;\n    return <Primitive.div role=\"group\" {...groupProps} ref={forwardedRef} />;\n  }\n);\n\nMenuGroup.displayName = GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuLabel\n * -----------------------------------------------------------------------------------------------*/\n\nconst LABEL_NAME = 'MenuLabel';\n\ntype MenuLabelElement = React.ElementRef<typeof Primitive.div>;\ninterface MenuLabelProps extends PrimitiveDivProps {}\n\nconst MenuLabel = React.forwardRef<MenuLabelElement, MenuLabelProps>(\n  (props: ScopedProps<MenuLabelProps>, forwardedRef) => {\n    const { __scopeMenu, ...labelProps } = props;\n    return <Primitive.div {...labelProps} ref={forwardedRef} />;\n  }\n);\n\nMenuLabel.displayName = LABEL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'MenuItem';\nconst ITEM_SELECT = 'menu.itemSelect';\n\ntype MenuItemElement = MenuItemImplElement;\ninterface MenuItemProps extends Omit<MenuItemImplProps, 'onSelect'> {\n  onSelect?: (event: Event) => void;\n}\n\nconst MenuItem = React.forwardRef<MenuItemElement, MenuItemProps>(\n  (props: ScopedProps<MenuItemProps>, forwardedRef) => {\n    const { disabled = false, onSelect, ...itemProps } = props;\n    const ref = React.useRef<HTMLDivElement>(null);\n    const rootContext = useMenuRootContext(ITEM_NAME, props.__scopeMenu);\n    const contentContext = useMenuContentContext(ITEM_NAME, props.__scopeMenu);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const isPointerDownRef = React.useRef(false);\n\n    const handleSelect = () => {\n      const menuItem = ref.current;\n      if (!disabled && menuItem) {\n        const itemSelectEvent = new CustomEvent(ITEM_SELECT, { bubbles: true, cancelable: true });\n        menuItem.addEventListener(ITEM_SELECT, (event) => onSelect?.(event), { once: true });\n        dispatchDiscreteCustomEvent(menuItem, itemSelectEvent);\n        if (itemSelectEvent.defaultPrevented) {\n          isPointerDownRef.current = false;\n        } else {\n          rootContext.onClose();\n        }\n      }\n    };\n\n    return (\n      <MenuItemImpl\n        {...itemProps}\n        ref={composedRefs}\n        disabled={disabled}\n        onClick={composeEventHandlers(props.onClick, handleSelect)}\n        onPointerDown={(event) => {\n          props.onPointerDown?.(event);\n          isPointerDownRef.current = true;\n        }}\n        onPointerUp={composeEventHandlers(props.onPointerUp, (event) => {\n          // Pointer down can move to a different menu item which should activate it on pointer up.\n          // We dispatch a click for selection to allow composition with click based triggers and to\n          // prevent Firefox from getting stuck in text selection mode when the menu closes.\n          if (!isPointerDownRef.current) event.currentTarget?.click();\n        })}\n        onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n          const isTypingAhead = contentContext.searchRef.current !== '';\n          if (disabled || (isTypingAhead && event.key === ' ')) return;\n          if (SELECTION_KEYS.includes(event.key)) {\n            event.currentTarget.click();\n            /**\n             * We prevent default browser behaviour for selection keys as they should trigger\n             * a selection only:\n             * - prevents space from scrolling the page.\n             * - if keydown causes focus to move, prevents keydown from firing on the new target.\n             */\n            event.preventDefault();\n          }\n        })}\n      />\n    );\n  }\n);\n\nMenuItem.displayName = ITEM_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuItemImplElement = React.ElementRef<typeof Primitive.div>;\ninterface MenuItemImplProps extends PrimitiveDivProps {\n  disabled?: boolean;\n  textValue?: string;\n}\n\nconst MenuItemImpl = React.forwardRef<MenuItemImplElement, MenuItemImplProps>(\n  (props: ScopedProps<MenuItemImplProps>, forwardedRef) => {\n    const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;\n    const contentContext = useMenuContentContext(ITEM_NAME, __scopeMenu);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);\n    const ref = React.useRef<HTMLDivElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const [isFocused, setIsFocused] = React.useState(false);\n\n    // get the item's `.textContent` as default strategy for typeahead `textValue`\n    const [textContent, setTextContent] = React.useState('');\n    React.useEffect(() => {\n      const menuItem = ref.current;\n      if (menuItem) {\n        setTextContent((menuItem.textContent ?? '').trim());\n      }\n    }, [itemProps.children]);\n\n    return (\n      <Collection.ItemSlot\n        scope={__scopeMenu}\n        disabled={disabled}\n        textValue={textValue ?? textContent}\n      >\n        <RovingFocusGroup.Item asChild {...rovingFocusGroupScope} focusable={!disabled}>\n          <Primitive.div\n            role=\"menuitem\"\n            data-highlighted={isFocused ? '' : undefined}\n            aria-disabled={disabled || undefined}\n            data-disabled={disabled ? '' : undefined}\n            {...itemProps}\n            ref={composedRefs}\n            /**\n             * We focus items on `pointerMove` to achieve the following:\n             *\n             * - Mouse over an item (it focuses)\n             * - Leave mouse where it is and use keyboard to focus a different item\n             * - Wiggle mouse without it leaving previously focused item\n             * - Previously focused item should re-focus\n             *\n             * If we used `mouseOver`/`mouseEnter` it would not re-focus when the mouse\n             * wiggles. This is to match native menu implementation.\n             */\n            onPointerMove={composeEventHandlers(\n              props.onPointerMove,\n              whenMouse((event) => {\n                if (disabled) {\n                  contentContext.onItemLeave(event);\n                } else {\n                  contentContext.onItemEnter(event);\n                  if (!event.defaultPrevented) {\n                    const item = event.currentTarget;\n                    item.focus({ preventScroll: true });\n                  }\n                }\n              })\n            )}\n            onPointerLeave={composeEventHandlers(\n              props.onPointerLeave,\n              whenMouse((event) => contentContext.onItemLeave(event))\n            )}\n            onFocus={composeEventHandlers(props.onFocus, () => setIsFocused(true))}\n            onBlur={composeEventHandlers(props.onBlur, () => setIsFocused(false))}\n          />\n        </RovingFocusGroup.Item>\n      </Collection.ItemSlot>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * MenuCheckboxItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst CHECKBOX_ITEM_NAME = 'MenuCheckboxItem';\n\ntype MenuCheckboxItemElement = MenuItemElement;\n\ntype CheckedState = boolean | 'indeterminate';\n\ninterface MenuCheckboxItemProps extends MenuItemProps {\n  checked?: CheckedState;\n  // `onCheckedChange` can never be called with `\"indeterminate\"` from the inside\n  onCheckedChange?: (checked: boolean) => void;\n}\n\nconst MenuCheckboxItem = React.forwardRef<MenuCheckboxItemElement, MenuCheckboxItemProps>(\n  (props: ScopedProps<MenuCheckboxItemProps>, forwardedRef) => {\n    const { checked = false, onCheckedChange, ...checkboxItemProps } = props;\n    return (\n      <ItemIndicatorProvider scope={props.__scopeMenu} checked={checked}>\n        <MenuItem\n          role=\"menuitemcheckbox\"\n          aria-checked={isIndeterminate(checked) ? 'mixed' : checked}\n          {...checkboxItemProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(checked)}\n          onSelect={composeEventHandlers(\n            checkboxItemProps.onSelect,\n            () => onCheckedChange?.(isIndeterminate(checked) ? true : !checked),\n            { checkForDefaultPrevented: false }\n          )}\n        />\n      </ItemIndicatorProvider>\n    );\n  }\n);\n\nMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuRadioGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_GROUP_NAME = 'MenuRadioGroup';\n\nconst [RadioGroupProvider, useRadioGroupContext] = createMenuContext<MenuRadioGroupProps>(\n  RADIO_GROUP_NAME,\n  { value: undefined, onValueChange: () => {} }\n);\n\ntype MenuRadioGroupElement = React.ElementRef<typeof MenuGroup>;\ninterface MenuRadioGroupProps extends MenuGroupProps {\n  value?: string;\n  onValueChange?: (value: string) => void;\n}\n\nconst MenuRadioGroup = React.forwardRef<MenuRadioGroupElement, MenuRadioGroupProps>(\n  (props: ScopedProps<MenuRadioGroupProps>, forwardedRef) => {\n    const { value, onValueChange, ...groupProps } = props;\n    const handleValueChange = useCallbackRef(onValueChange);\n    return (\n      <RadioGroupProvider scope={props.__scopeMenu} value={value} onValueChange={handleValueChange}>\n        <MenuGroup {...groupProps} ref={forwardedRef} />\n      </RadioGroupProvider>\n    );\n  }\n);\n\nMenuRadioGroup.displayName = RADIO_GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuRadioItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_ITEM_NAME = 'MenuRadioItem';\n\ntype MenuRadioItemElement = React.ElementRef<typeof MenuItem>;\ninterface MenuRadioItemProps extends MenuItemProps {\n  value: string;\n}\n\nconst MenuRadioItem = React.forwardRef<MenuRadioItemElement, MenuRadioItemProps>(\n  (props: ScopedProps<MenuRadioItemProps>, forwardedRef) => {\n    const { value, ...radioItemProps } = props;\n    const context = useRadioGroupContext(RADIO_ITEM_NAME, props.__scopeMenu);\n    const checked = value === context.value;\n    return (\n      <ItemIndicatorProvider scope={props.__scopeMenu} checked={checked}>\n        <MenuItem\n          role=\"menuitemradio\"\n          aria-checked={checked}\n          {...radioItemProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(checked)}\n          onSelect={composeEventHandlers(\n            radioItemProps.onSelect,\n            () => context.onValueChange?.(value),\n            { checkForDefaultPrevented: false }\n          )}\n        />\n      </ItemIndicatorProvider>\n    );\n  }\n);\n\nMenuRadioItem.displayName = RADIO_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuItemIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_INDICATOR_NAME = 'MenuItemIndicator';\n\ntype CheckboxContextValue = { checked: CheckedState };\n\nconst [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext<CheckboxContextValue>(\n  ITEM_INDICATOR_NAME,\n  { checked: false }\n);\n\ntype MenuItemIndicatorElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = React.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface MenuItemIndicatorProps extends PrimitiveSpanProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuItemIndicator = React.forwardRef<MenuItemIndicatorElement, MenuItemIndicatorProps>(\n  (props: ScopedProps<MenuItemIndicatorProps>, forwardedRef) => {\n    const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;\n    const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME, __scopeMenu);\n    return (\n      <Presence\n        present={\n          forceMount ||\n          isIndeterminate(indicatorContext.checked) ||\n          indicatorContext.checked === true\n        }\n      >\n        <Primitive.span\n          {...itemIndicatorProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(indicatorContext.checked)}\n        />\n      </Presence>\n    );\n  }\n);\n\nMenuItemIndicator.displayName = ITEM_INDICATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSeparator\n * -----------------------------------------------------------------------------------------------*/\n\nconst SEPARATOR_NAME = 'MenuSeparator';\n\ntype MenuSeparatorElement = React.ElementRef<typeof Primitive.div>;\ninterface MenuSeparatorProps extends PrimitiveDivProps {}\n\nconst MenuSeparator = React.forwardRef<MenuSeparatorElement, MenuSeparatorProps>(\n  (props: ScopedProps<MenuSeparatorProps>, forwardedRef) => {\n    const { __scopeMenu, ...separatorProps } = props;\n    return (\n      <Primitive.div\n        role=\"separator\"\n        aria-orientation=\"horizontal\"\n        {...separatorProps}\n        ref={forwardedRef}\n      />\n    );\n  }\n);\n\nMenuSeparator.displayName = SEPARATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'MenuArrow';\n\ntype MenuArrowElement = React.ElementRef<typeof PopperPrimitive.Arrow>;\ntype PopperArrowProps = React.ComponentPropsWithoutRef<typeof PopperPrimitive.Arrow>;\ninterface MenuArrowProps extends PopperArrowProps {}\n\nconst MenuArrow = React.forwardRef<MenuArrowElement, MenuArrowProps>(\n  (props: ScopedProps<MenuArrowProps>, forwardedRef) => {\n    const { __scopeMenu, ...arrowProps } = props;\n    const popperScope = usePopperScope(__scopeMenu);\n    return <PopperPrimitive.Arrow {...popperScope} {...arrowProps} ref={forwardedRef} />;\n  }\n);\n\nMenuArrow.displayName = ARROW_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSub\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_NAME = 'MenuSub';\n\ntype MenuSubContextValue = {\n  contentId: string;\n  triggerId: string;\n  trigger: MenuSubTriggerElement | null;\n  onTriggerChange(trigger: MenuSubTriggerElement | null): void;\n};\n\nconst [MenuSubProvider, useMenuSubContext] = createMenuContext<MenuSubContextValue>(SUB_NAME);\n\ninterface MenuSubProps {\n  children?: React.ReactNode;\n  open?: boolean;\n  onOpenChange?(open: boolean): void;\n}\n\nconst MenuSub: React.FC<MenuSubProps> = (props: ScopedProps<MenuSubProps>) => {\n  const { __scopeMenu, children, open = false, onOpenChange } = props;\n  const parentMenuContext = useMenuContext(SUB_NAME, __scopeMenu);\n  const popperScope = usePopperScope(__scopeMenu);\n  const [trigger, setTrigger] = React.useState<MenuSubTriggerElement | null>(null);\n  const [content, setContent] = React.useState<MenuContentElement | null>(null);\n  const handleOpenChange = useCallbackRef(onOpenChange);\n\n  // Prevent the parent menu from reopening with open submenus.\n  React.useEffect(() => {\n    if (parentMenuContext.open === false) handleOpenChange(false);\n    return () => handleOpenChange(false);\n  }, [parentMenuContext.open, handleOpenChange]);\n\n  return (\n    <PopperPrimitive.Root {...popperScope}>\n      <MenuProvider\n        scope={__scopeMenu}\n        open={open}\n        onOpenChange={handleOpenChange}\n        content={content}\n        onContentChange={setContent}\n      >\n        <MenuSubProvider\n          scope={__scopeMenu}\n          contentId={useId()}\n          triggerId={useId()}\n          trigger={trigger}\n          onTriggerChange={setTrigger}\n        >\n          {children}\n        </MenuSubProvider>\n      </MenuProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nMenuSub.displayName = SUB_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSubTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_TRIGGER_NAME = 'MenuSubTrigger';\n\ntype MenuSubTriggerElement = MenuItemImplElement;\ninterface MenuSubTriggerProps extends MenuItemImplProps {}\n\nconst MenuSubTrigger = React.forwardRef<MenuSubTriggerElement, MenuSubTriggerProps>(\n  (props: ScopedProps<MenuSubTriggerProps>, forwardedRef) => {\n    const context = useMenuContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const rootContext = useMenuRootContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const subContext = useMenuSubContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const contentContext = useMenuContentContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const openTimerRef = React.useRef<number | null>(null);\n    const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;\n    const scope = { __scopeMenu: props.__scopeMenu };\n\n    const clearOpenTimer = React.useCallback(() => {\n      if (openTimerRef.current) window.clearTimeout(openTimerRef.current);\n      openTimerRef.current = null;\n    }, []);\n\n    React.useEffect(() => clearOpenTimer, [clearOpenTimer]);\n\n    React.useEffect(() => {\n      const pointerGraceTimer = pointerGraceTimerRef.current;\n      return () => {\n        window.clearTimeout(pointerGraceTimer);\n        onPointerGraceIntentChange(null);\n      };\n    }, [pointerGraceTimerRef, onPointerGraceIntentChange]);\n\n    return (\n      <MenuAnchor asChild {...scope}>\n        <MenuItemImpl\n          id={subContext.triggerId}\n          aria-haspopup=\"menu\"\n          aria-expanded={context.open}\n          aria-controls={subContext.contentId}\n          data-state={getOpenState(context.open)}\n          {...props}\n          ref={composeRefs(forwardedRef, subContext.onTriggerChange)}\n          // This is redundant for mouse users but we cannot determine pointer type from\n          // click event and we cannot use pointerup event (see git history for reasons why)\n          onClick={(event) => {\n            props.onClick?.(event);\n            if (props.disabled || event.defaultPrevented) return;\n            /**\n             * We manually focus because iOS Safari doesn't always focus on click (e.g. buttons)\n             * and we rely heavily on `onFocusOutside` for submenus to close when switching\n             * between separate submenus.\n             */\n            event.currentTarget.focus();\n            if (!context.open) context.onOpenChange(true);\n          }}\n          onPointerMove={composeEventHandlers(\n            props.onPointerMove,\n            whenMouse((event) => {\n              contentContext.onItemEnter(event);\n              if (event.defaultPrevented) return;\n              if (!props.disabled && !context.open && !openTimerRef.current) {\n                contentContext.onPointerGraceIntentChange(null);\n                openTimerRef.current = window.setTimeout(() => {\n                  context.onOpenChange(true);\n                  clearOpenTimer();\n                }, 100);\n              }\n            })\n          )}\n          onPointerLeave={composeEventHandlers(\n            props.onPointerLeave,\n            whenMouse((event) => {\n              clearOpenTimer();\n\n              const contentRect = context.content?.getBoundingClientRect();\n              if (contentRect) {\n                // TODO: make sure to update this when we change positioning logic\n                const side = context.content?.dataset.side as Side;\n                const rightSide = side === 'right';\n                const bleed = rightSide ? -5 : +5;\n                const contentNearEdge = contentRect[rightSide ? 'left' : 'right'];\n                const contentFarEdge = contentRect[rightSide ? 'right' : 'left'];\n\n                contentContext.onPointerGraceIntentChange({\n                  area: [\n                    // Apply a bleed on clientX to ensure that our exit point is\n                    // consistently within polygon bounds\n                    { x: event.clientX + bleed, y: event.clientY },\n                    { x: contentNearEdge, y: contentRect.top },\n                    { x: contentFarEdge, y: contentRect.top },\n                    { x: contentFarEdge, y: contentRect.bottom },\n                    { x: contentNearEdge, y: contentRect.bottom },\n                  ],\n                  side,\n                });\n\n                window.clearTimeout(pointerGraceTimerRef.current);\n                pointerGraceTimerRef.current = window.setTimeout(\n                  () => contentContext.onPointerGraceIntentChange(null),\n                  300\n                );\n              } else {\n                contentContext.onTriggerLeave(event);\n                if (event.defaultPrevented) return;\n\n                // There's 100ms where the user may leave an item before the submenu was opened.\n                contentContext.onPointerGraceIntentChange(null);\n              }\n            })\n          )}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            const isTypingAhead = contentContext.searchRef.current !== '';\n            if (props.disabled || (isTypingAhead && event.key === ' ')) return;\n            if (SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {\n              context.onOpenChange(true);\n              // The trigger may hold focus if opened via pointer interaction\n              // so we ensure content is given focus again when switching to keyboard.\n              context.content?.focus();\n              // prevent window from scrolling\n              event.preventDefault();\n            }\n          })}\n        />\n      </MenuAnchor>\n    );\n  }\n);\n\nMenuSubTrigger.displayName = SUB_TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSubContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_CONTENT_NAME = 'MenuSubContent';\n\ntype MenuSubContentElement = MenuContentImplElement;\ninterface MenuSubContentProps\n  extends Omit<\n    MenuContentImplProps,\n    keyof MenuContentImplPrivateProps | 'onCloseAutoFocus' | 'onEntryFocus' | 'side' | 'align'\n  > {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuSubContent = React.forwardRef<MenuSubContentElement, MenuSubContentProps>(\n  (props: ScopedProps<MenuSubContentProps>, forwardedRef) => {\n    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeMenu);\n    const { forceMount = portalContext.forceMount, ...subContentProps } = props;\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    const rootContext = useMenuRootContext(CONTENT_NAME, props.__scopeMenu);\n    const subContext = useMenuSubContext(SUB_CONTENT_NAME, props.__scopeMenu);\n    const ref = React.useRef<MenuSubContentElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    return (\n      <Collection.Provider scope={props.__scopeMenu}>\n        <Presence present={forceMount || context.open}>\n          <Collection.Slot scope={props.__scopeMenu}>\n            <MenuContentImpl\n              id={subContext.contentId}\n              aria-labelledby={subContext.triggerId}\n              {...subContentProps}\n              ref={composedRefs}\n              align=\"start\"\n              side={rootContext.dir === 'rtl' ? 'left' : 'right'}\n              disableOutsidePointerEvents={false}\n              disableOutsideScroll={false}\n              trapFocus={false}\n              onOpenAutoFocus={(event) => {\n                // when opening a submenu, focus content for keyboard users only\n                if (rootContext.isUsingKeyboardRef.current) ref.current?.focus();\n                event.preventDefault();\n              }}\n              // The menu might close because of focusing another menu item in the parent menu. We\n              // don't want it to refocus the trigger in that case so we handle trigger focus ourselves.\n              onCloseAutoFocus={(event) => event.preventDefault()}\n              onFocusOutside={composeEventHandlers(props.onFocusOutside, (event) => {\n                // We prevent closing when the trigger is focused to avoid triggering a re-open animation\n                // on pointer interaction.\n                if (event.target !== subContext.trigger) context.onOpenChange(false);\n              })}\n              onEscapeKeyDown={composeEventHandlers(props.onEscapeKeyDown, (event) => {\n                rootContext.onClose();\n                // ensure pressing escape in submenu doesn't escape full screen mode\n                event.preventDefault();\n              })}\n              onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n                // Submenu key events bubble through portals. We only care about keys in this menu.\n                const isKeyDownInside = event.currentTarget.contains(event.target as HTMLElement);\n                const isCloseKey = SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);\n                if (isKeyDownInside && isCloseKey) {\n                  context.onOpenChange(false);\n                  // We focus manually because we prevented it in `onCloseAutoFocus`\n                  subContext.trigger?.focus();\n                  // prevent window from scrolling\n                  event.preventDefault();\n                }\n              })}\n            />\n          </Collection.Slot>\n        </Presence>\n      </Collection.Provider>\n    );\n  }\n);\n\nMenuSubContent.displayName = SUB_CONTENT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getOpenState(open: boolean) {\n  return open ? 'open' : 'closed';\n}\n\nfunction isIndeterminate(checked?: CheckedState): checked is 'indeterminate' {\n  return checked === 'indeterminate';\n}\n\nfunction getCheckedState(checked: CheckedState) {\n  return isIndeterminate(checked) ? 'indeterminate' : checked ? 'checked' : 'unchecked';\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus();\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n\n/**\n * This is the \"meat\" of the typeahead matching logic. It takes in all the values,\n * the search and the current match, and returns the next match (or `undefined`).\n *\n * We normalize the search because if a user has repeatedly pressed a character,\n * we want the exact same behavior as if we only had that one character\n * (ie. cycle through options starting with that character)\n *\n * We also reorder the values by wrapping the array around the current match.\n * This is so we always look forward from the current match, and picking the first\n * match will always be the correct one.\n *\n * Finally, if the normalized search is exactly one character, we exclude the\n * current match from the values because otherwise it would be the first to match always\n * and focus would never move. This is as opposed to the regular case, where we\n * don't want focus to move if the current match still matches.\n */\nfunction getNextMatch(values: string[], search: string, currentMatch?: string) {\n  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);\n  const normalizedSearch = isRepeated ? search[0] : search;\n  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;\n  let wrappedValues = wrapArray(values, Math.max(currentMatchIndex, 0));\n  const excludeCurrentMatch = normalizedSearch.length === 1;\n  if (excludeCurrentMatch) wrappedValues = wrappedValues.filter((v) => v !== currentMatch);\n  const nextMatch = wrappedValues.find((value) =>\n    value.toLowerCase().startsWith(normalizedSearch.toLowerCase())\n  );\n  return nextMatch !== currentMatch ? nextMatch : undefined;\n}\n\ntype Point = { x: number; y: number };\ntype Polygon = Point[];\ntype Side = 'left' | 'right';\ntype GraceIntent = { area: Polygon; side: Side };\n\n// Determine if a point is inside of a polygon.\n// Based on https://github.com/substack/point-in-polygon\nfunction isPointInPolygon(point: Point, polygon: Polygon) {\n  const { x, y } = point;\n  let inside = false;\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x;\n    const yi = polygon[i].y;\n    const xj = polygon[j].x;\n    const yj = polygon[j].y;\n\n    // prettier-ignore\n    const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n    if (intersect) inside = !inside;\n  }\n\n  return inside;\n}\n\nfunction isPointerInGraceArea(event: React.PointerEvent, area?: Polygon) {\n  if (!area) return false;\n  const cursorPos = { x: event.clientX, y: event.clientY };\n  return isPointInPolygon(cursorPos, area);\n}\n\nfunction whenMouse<E>(handler: React.PointerEventHandler<E>): React.PointerEventHandler<E> {\n  return (event) => (event.pointerType === 'mouse' ? handler(event) : undefined);\n}\n\nconst Root = Menu;\nconst Anchor = MenuAnchor;\nconst Portal = MenuPortal;\nconst Content = MenuContent;\nconst Group = MenuGroup;\nconst Label = MenuLabel;\nconst Item = MenuItem;\nconst CheckboxItem = MenuCheckboxItem;\nconst RadioGroup = MenuRadioGroup;\nconst RadioItem = MenuRadioItem;\nconst ItemIndicator = MenuItemIndicator;\nconst Separator = MenuSeparator;\nconst Arrow = MenuArrow;\nconst Sub = MenuSub;\nconst SubTrigger = MenuSubTrigger;\nconst SubContent = MenuSubContent;\n\nexport {\n  createMenuScope,\n  //\n  Menu,\n  MenuAnchor,\n  MenuPortal,\n  MenuContent,\n  MenuGroup,\n  MenuLabel,\n  MenuItem,\n  MenuCheckboxItem,\n  MenuRadioGroup,\n  MenuRadioItem,\n  MenuItemIndicator,\n  MenuSeparator,\n  MenuArrow,\n  MenuSub,\n  MenuSubTrigger,\n  MenuSubContent,\n  //\n  Root,\n  Anchor,\n  Portal,\n  Content,\n  Group,\n  Label,\n  Item,\n  CheckboxItem,\n  RadioGroup,\n  RadioItem,\n  ItemIndicator,\n  Separator,\n  Arrow,\n  Sub,\n  SubTrigger,\n  SubContent,\n};\nexport type {\n  MenuProps,\n  MenuAnchorProps,\n  MenuPortalProps,\n  MenuContentProps,\n  MenuGroupProps,\n  MenuLabelProps,\n  MenuItemProps,\n  MenuCheckboxItemProps,\n  MenuRadioGroupProps,\n  MenuRadioItemProps,\n  MenuItemIndicatorProps,\n  MenuSeparatorProps,\n  MenuArrowProps,\n  MenuSubProps,\n  MenuSubTriggerProps,\n  MenuSubContentProps,\n};\n"],"names":["Root","Anchor","Content","Item","Arrow"],"mappings":"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"}},
    {"offset": {"line": 922, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}