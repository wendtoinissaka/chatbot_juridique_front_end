{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/rsc/dist/rsc-shared.mjs/proxy.js"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport const InternalAIProvider = registerClientReference(\n    function() { throw new Error(\"Attempted to call InternalAIProvider() from the server but InternalAIProvider is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/rsc/dist/rsc-shared.mjs\",\n    \"InternalAIProvider\",\n);\nexport const readStreamableValue = registerClientReference(\n    function() { throw new Error(\"Attempted to call readStreamableValue() from the server but readStreamableValue is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/rsc/dist/rsc-shared.mjs\",\n    \"readStreamableValue\",\n);\nexport const useAIState = registerClientReference(\n    function() { throw new Error(\"Attempted to call useAIState() from the server but useAIState is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/rsc/dist/rsc-shared.mjs\",\n    \"useAIState\",\n);\nexport const useActions = registerClientReference(\n    function() { throw new Error(\"Attempted to call useActions() from the server but useActions is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/rsc/dist/rsc-shared.mjs\",\n    \"useActions\",\n);\nexport const useStreamableValue = registerClientReference(\n    function() { throw new Error(\"Attempted to call useStreamableValue() from the server but useStreamableValue is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/rsc/dist/rsc-shared.mjs\",\n    \"useStreamableValue\",\n);\nexport const useSyncUIState = registerClientReference(\n    function() { throw new Error(\"Attempted to call useSyncUIState() from the server but useSyncUIState is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/rsc/dist/rsc-shared.mjs\",\n    \"useSyncUIState\",\n);\nexport const useUIState = registerClientReference(\n    function() { throw new Error(\"Attempted to call useUIState() from the server but useUIState is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/rsc/dist/rsc-shared.mjs\",\n    \"useUIState\",\n);\n"],"names":[],"mappings":";;;;;;;;;;;;AACO,MAAM,qBAAqB,CAAA,GAAA,saAAA,CAAA,0BAAuB,AAAD,EACpD;IAAa,MAAM,IAAI,MAAM;AAAoP,GACjR,iMACA;AAEG,MAAM,sBAAsB,CAAA,GAAA,saAAA,CAAA,0BAAuB,AAAD,EACrD;IAAa,MAAM,IAAI,MAAM;AAAsP,GACnR,iMACA;AAEG,MAAM,aAAa,CAAA,GAAA,saAAA,CAAA,0BAAuB,AAAD,EAC5C;IAAa,MAAM,IAAI,MAAM;AAAoO,GACjQ,iMACA;AAEG,MAAM,aAAa,CAAA,GAAA,saAAA,CAAA,0BAAuB,AAAD,EAC5C;IAAa,MAAM,IAAI,MAAM;AAAoO,GACjQ,iMACA;AAEG,MAAM,qBAAqB,CAAA,GAAA,saAAA,CAAA,0BAAuB,AAAD,EACpD;IAAa,MAAM,IAAI,MAAM;AAAoP,GACjR,iMACA;AAEG,MAAM,iBAAiB,CAAA,GAAA,saAAA,CAAA,0BAAuB,AAAD,EAChD;IAAa,MAAM,IAAI,MAAM;AAA4O,GACzQ,iMACA;AAEG,MAAM,aAAa,CAAA,GAAA,saAAA,CAAA,0BAAuB,AAAD,EAC5C;IAAa,MAAM,IAAI,MAAM;AAAoO,GACjQ,iMACA"}},
    {"offset": {"line": 38, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 43, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/rsc/streamable-value/streamable-value.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/rsc/streamable-value/is-streamable-value.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/rsc/streamable-value/read-streamable-value.tsx","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/rsc/streamable-value/use-streamable-value.tsx","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/rsc/shared-client/context.tsx","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/util/is-function.ts"],"sourcesContent":["export const STREAMABLE_VALUE_TYPE = Symbol.for('ui.streamable.value');\n\nexport type StreamablePatch = undefined | [0, string]; // Append string.\n\ndeclare const __internal_curr: unique symbol;\ndeclare const __internal_error: unique symbol;\n\n/**\n * StreamableValue is a value that can be streamed over the network via AI Actions.\n * To read the streamed values, use the `readStreamableValue` or `useStreamableValue` APIs.\n */\nexport type StreamableValue<T = any, E = any> = {\n  /**\n   * @internal Use `readStreamableValue` to read the values.\n   */\n  type?: typeof STREAMABLE_VALUE_TYPE;\n  /**\n   * @internal Use `readStreamableValue` to read the values.\n   */\n  curr?: T;\n  /**\n   * @internal Use `readStreamableValue` to read the values.\n   */\n  error?: E;\n  /**\n   * @internal Use `readStreamableValue` to read the values.\n   */\n  diff?: StreamablePatch;\n  /**\n   * @internal Use `readStreamableValue` to read the values.\n   */\n  next?: Promise<StreamableValue<T, E>>;\n\n  // branded types to maintain type signature after internal properties are stripped.\n  [__internal_curr]?: T;\n  [__internal_error]?: E;\n};\n","import { STREAMABLE_VALUE_TYPE, StreamableValue } from './streamable-value';\n\nexport function isStreamableValue(value: unknown): value is StreamableValue {\n  return (\n    value != null &&\n    typeof value === 'object' &&\n    'type' in value &&\n    value.type === STREAMABLE_VALUE_TYPE\n  );\n}\n","import { isStreamableValue } from './is-streamable-value';\nimport { StreamableValue } from './streamable-value';\n\n/**\n * `readStreamableValue` takes a streamable value created via the `createStreamableValue().value` API,\n * and returns an async iterator.\n *\n * ```js\n * // Inside your AI action:\n *\n * async function action() {\n *   'use server'\n *   const streamable = createStreamableValue();\n *\n *   streamable.update(1);\n *   streamable.update(2);\n *   streamable.done(3);\n *   // ...\n *   return streamable.value;\n * }\n * ```\n *\n * And to read the value:\n *\n * ```js\n * const streamableValue = await action()\n * for await (const v of readStreamableValue(streamableValue)) {\n *   console.log(v)\n * }\n * ```\n *\n * This logs out 1, 2, 3 on console.\n */\nexport function readStreamableValue<T = unknown>(\n  streamableValue: StreamableValue<T>,\n): AsyncIterable<T | undefined> {\n  if (!isStreamableValue(streamableValue)) {\n    throw new Error(\n      'Invalid value: this hook only accepts values created via `createStreamableValue`.',\n    );\n  }\n\n  return {\n    [Symbol.asyncIterator]() {\n      let row: StreamableValue<T> | Promise<StreamableValue<T>> =\n        streamableValue;\n      let value = row.curr; // the current value\n      let isDone = false;\n      let isFirstIteration = true;\n\n      return {\n        async next() {\n          // the iteration is done already, return the last value:\n          if (isDone) return { value, done: true };\n\n          // resolve the promise at the beginning of each iteration:\n          row = await row;\n\n          // throw error if any:\n          if (row.error !== undefined) {\n            throw row.error;\n          }\n\n          // if there is a value or a patch, use it:\n          if ('curr' in row || row.diff) {\n            if (row.diff) {\n              // streamable patch (text only):\n              if (row.diff[0] === 0) {\n                if (typeof value !== 'string') {\n                  throw new Error(\n                    'Invalid patch: can only append to string types. This is a bug in the AI SDK.',\n                  );\n                }\n\n                // casting required to remove T & string limitation\n                (value as string) = value + row.diff[1];\n              }\n            } else {\n              // replace the value (full new value)\n              value = row.curr;\n            }\n\n            // The last emitted { done: true } won't be used as the value\n            // by the for await...of syntax.\n            if (!row.next) {\n              isDone = true;\n              return { value, done: false };\n            }\n          }\n\n          // there are no further rows to iterate over:\n          if (row.next === undefined) {\n            return { value, done: true };\n          }\n\n          row = row.next;\n\n          if (isFirstIteration) {\n            isFirstIteration = false; // TODO should this be set for every return?\n\n            if (value === undefined) {\n              // This is the initial chunk and there isn't an initial value yet.\n              // Let's skip this one.\n              return this.next();\n            }\n          }\n\n          return { value, done: false };\n        },\n      };\n    },\n  };\n}\n","import { startTransition, useLayoutEffect, useState } from 'react';\nimport { readStreamableValue } from './read-streamable-value';\nimport { StreamableValue } from './streamable-value';\nimport { isStreamableValue } from './is-streamable-value';\n\nfunction checkStreamableValue(value: unknown): value is StreamableValue {\n  const hasSignature = isStreamableValue(value);\n\n  if (!hasSignature && value !== undefined) {\n    throw new Error(\n      'Invalid value: this hook only accepts values created via `createStreamableValue`.',\n    );\n  }\n\n  return hasSignature;\n}\n\n/**\n * `useStreamableValue` is a React hook that takes a streamable value created via the `createStreamableValue().value` API,\n * and returns the current value, error, and pending state.\n *\n * This is useful for consuming streamable values received from a component's props. For example:\n *\n * ```js\n * function MyComponent({ streamableValue }) {\n *   const [data, error, pending] = useStreamableValue(streamableValue);\n *\n *   if (pending) return <div>Loading...</div>;\n *   if (error) return <div>Error: {error.message}</div>;\n *\n *   return <div>Data: {data}</div>;\n * }\n * ```\n */\nexport function useStreamableValue<T = unknown, Error = unknown>(\n  streamableValue?: StreamableValue<T>,\n): [data: T | undefined, error: Error | undefined, pending: boolean] {\n  const [curr, setCurr] = useState<T | undefined>(\n    checkStreamableValue(streamableValue) ? streamableValue.curr : undefined,\n  );\n  const [error, setError] = useState<Error | undefined>(\n    checkStreamableValue(streamableValue) ? streamableValue.error : undefined,\n  );\n  const [pending, setPending] = useState<boolean>(\n    checkStreamableValue(streamableValue) ? !!streamableValue.next : false,\n  );\n\n  useLayoutEffect(() => {\n    if (!checkStreamableValue(streamableValue)) return;\n\n    let cancelled = false;\n\n    const iterator = readStreamableValue(streamableValue);\n    if (streamableValue.next) {\n      startTransition(() => {\n        if (cancelled) return;\n        setPending(true);\n      });\n    }\n\n    (async () => {\n      try {\n        for await (const value of iterator) {\n          if (cancelled) return;\n          startTransition(() => {\n            if (cancelled) return;\n            setCurr(value);\n          });\n        }\n      } catch (e) {\n        if (cancelled) return;\n        startTransition(() => {\n          if (cancelled) return;\n          setError(e as Error);\n        });\n      } finally {\n        if (cancelled) return;\n        startTransition(() => {\n          if (cancelled) return;\n          setPending(false);\n        });\n      }\n    })();\n\n    return () => {\n      cancelled = true;\n    };\n  }, [streamableValue]);\n\n  return [curr, error, pending];\n}\n","/* eslint-disable react-hooks/exhaustive-deps */\n'use client';\n\nimport * as React from 'react';\n\nimport * as jsondiffpatch from 'jsondiffpatch';\nimport { isFunction } from '../../util/is-function';\nimport type {\n  AIProvider,\n  InferActions,\n  InferAIState,\n  InferUIState,\n  InternalAIProviderProps,\n  ValueOrUpdater,\n} from '../types';\n\nconst InternalUIStateProvider = React.createContext<null | any>(null);\nconst InternalAIStateProvider = React.createContext<undefined | any>(undefined);\nconst InternalActionProvider = React.createContext<null | any>(null);\nconst InternalSyncUIStateProvider = React.createContext<null | any>(null);\n\nexport function InternalAIProvider({\n  children,\n  initialUIState,\n  initialAIState,\n  initialAIStatePatch,\n  wrappedActions,\n  wrappedSyncUIState,\n}: InternalAIProviderProps) {\n  if (!('use' in React)) {\n    throw new Error('Unsupported React version.');\n  }\n\n  const uiState = React.useState(initialUIState);\n  const setUIState = uiState[1];\n\n  const resolvedInitialAIStatePatch = initialAIStatePatch\n    ? (React as any).use(initialAIStatePatch)\n    : undefined;\n  initialAIState = React.useMemo(() => {\n    if (resolvedInitialAIStatePatch) {\n      return jsondiffpatch.patch(\n        jsondiffpatch.clone(initialAIState),\n        resolvedInitialAIStatePatch,\n      );\n    }\n    return initialAIState;\n  }, [initialAIState, resolvedInitialAIStatePatch]);\n\n  const aiState = React.useState(initialAIState);\n  const setAIState = aiState[1];\n  const aiStateRef = React.useRef(aiState[0]);\n\n  React.useEffect(() => {\n    aiStateRef.current = aiState[0];\n  }, [aiState[0]]);\n\n  const clientWrappedActions = React.useMemo(\n    () =>\n      Object.fromEntries(\n        Object.entries(wrappedActions).map(([key, action]) => [\n          key,\n          async (...args: any) => {\n            const aiStateSnapshot = aiStateRef.current;\n            const [aiStateDelta, result] = await action(\n              aiStateSnapshot,\n              ...args,\n            );\n            (async () => {\n              const delta = await aiStateDelta;\n              if (delta !== undefined) {\n                aiState[1](\n                  jsondiffpatch.patch(\n                    jsondiffpatch.clone(aiStateSnapshot),\n                    delta,\n                  ),\n                );\n              }\n            })();\n            return result;\n          },\n        ]),\n      ),\n    [wrappedActions],\n  );\n\n  const clientWrappedSyncUIStateAction = React.useMemo(() => {\n    if (!wrappedSyncUIState) {\n      return () => {};\n    }\n\n    return async () => {\n      const aiStateSnapshot = aiStateRef.current;\n      const [aiStateDelta, uiState] = await wrappedSyncUIState!(\n        aiStateSnapshot,\n      );\n\n      if (uiState !== undefined) {\n        setUIState(uiState);\n      }\n\n      const delta = await aiStateDelta;\n      if (delta !== undefined) {\n        const patchedAiState = jsondiffpatch.patch(\n          jsondiffpatch.clone(aiStateSnapshot),\n          delta,\n        );\n        setAIState(patchedAiState);\n      }\n    };\n  }, [wrappedSyncUIState]);\n\n  return (\n    <InternalAIStateProvider.Provider value={aiState}>\n      <InternalUIStateProvider.Provider value={uiState}>\n        <InternalActionProvider.Provider value={clientWrappedActions}>\n          <InternalSyncUIStateProvider.Provider\n            value={clientWrappedSyncUIStateAction}\n          >\n            {children}\n          </InternalSyncUIStateProvider.Provider>\n        </InternalActionProvider.Provider>\n      </InternalUIStateProvider.Provider>\n    </InternalAIStateProvider.Provider>\n  );\n}\n\nexport function useUIState<AI extends AIProvider = any>() {\n  type T = InferUIState<AI, any>;\n\n  const state = React.useContext<\n    [T, (v: T | ((v_: T) => T)) => void] | null | undefined\n  >(InternalUIStateProvider);\n  if (state === null) {\n    throw new Error('`useUIState` must be used inside an <AI> provider.');\n  }\n  if (!Array.isArray(state)) {\n    throw new Error('Invalid state');\n  }\n  if (state[0] === undefined) {\n    throw new Error(\n      '`initialUIState` must be provided to `createAI` or `<AI>`',\n    );\n  }\n  return state;\n}\n\n// TODO: How do we avoid causing a re-render when the AI state changes but you\n// are only listening to a specific key? We need useSES perhaps?\nfunction useAIState<AI extends AIProvider = any>(): [\n  InferAIState<AI, any>,\n  (newState: ValueOrUpdater<InferAIState<AI, any>>) => void,\n];\nfunction useAIState<AI extends AIProvider = any>(\n  key: keyof InferAIState<AI, any>,\n): [\n  InferAIState<AI, any>[typeof key],\n  (newState: ValueOrUpdater<InferAIState<AI, any>[typeof key]>) => void,\n];\nfunction useAIState<AI extends AIProvider = any>(\n  ...args: [] | [keyof InferAIState<AI, any>]\n) {\n  type T = InferAIState<AI, any>;\n\n  const state = React.useContext<\n    [T, (newState: ValueOrUpdater<T>) => void] | null | undefined\n  >(InternalAIStateProvider);\n  if (state === null) {\n    throw new Error('`useAIState` must be used inside an <AI> provider.');\n  }\n  if (!Array.isArray(state)) {\n    throw new Error('Invalid state');\n  }\n  if (state[0] === undefined) {\n    throw new Error(\n      '`initialAIState` must be provided to `createAI` or `<AI>`',\n    );\n  }\n  if (args.length >= 1 && typeof state[0] !== 'object') {\n    throw new Error(\n      'When using `useAIState` with a key, the AI state must be an object.',\n    );\n  }\n\n  const key = args[0];\n  const setter = React.useCallback(\n    typeof key === 'undefined'\n      ? state[1]\n      : (newState: ValueOrUpdater<T>) => {\n          if (isFunction(newState)) {\n            return state[1](s => {\n              return { ...s, [key]: newState(s[key]) };\n            });\n          } else {\n            return state[1]({ ...state[0], [key]: newState });\n          }\n        },\n    [key],\n  );\n\n  if (args.length === 0) {\n    return state;\n  } else {\n    return [state[0][args[0]], setter];\n  }\n}\n\nexport function useActions<AI extends AIProvider = any>() {\n  type T = InferActions<AI, any>;\n\n  const actions = React.useContext<T>(InternalActionProvider);\n  return actions;\n}\n\nexport function useSyncUIState() {\n  const syncUIState = React.useContext<() => Promise<void>>(\n    InternalSyncUIStateProvider,\n  );\n\n  if (syncUIState === null) {\n    throw new Error('`useSyncUIState` must be used inside an <AI> provider.');\n  }\n\n  return syncUIState;\n}\n\nexport { useAIState };\n","/**\n * Checks if the given value is a function.\n *\n * @param {unknown} value - The value to check.\n * @returns {boolean} True if the value is a function, false otherwise.\n */\nexport const isFunction = (value: unknown): value is Function =>\n  typeof value === 'function';\n"],"names":[],"mappings":""}},
    {"offset": {"line": 48, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 53, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/rsc/ai-state.tsx","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/util/create-resolvable-promise.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/util/is-function.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/rsc/provider.tsx","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/rsc/stream-ui/stream-ui.tsx","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/core/prompt/convert-to-language-model-prompt.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/util/download-error.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/util/download.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/core/util/detect-image-mimetype.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/core/prompt/data-content.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/core/prompt/invalid-data-content-error.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/core/prompt/invalid-message-role-error.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/errors/invalid-argument-error.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/core/prompt/prepare-call-settings.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/core/prompt/prepare-tools-and-tool-choice.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/core/util/is-non-empty-object.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/core/prompt/validate-prompt.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/core/prompt/message.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/core/types/provider-metadata.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/core/types/json-value.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/core/prompt/content-part.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/core/types/token-usage.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/errors/invalid-tool-arguments-error.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/errors/no-such-tool-error.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/util/is-async-generator.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/util/is-generator.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/util/retry-with-exponential-backoff.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/util/delay.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/util/retry-error.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/util/constants.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/rsc/streamable-ui/create-suspended-chunk.tsx","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/rsc/streamable-ui/create-streamable-ui.tsx","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/rsc/stream-ui/render.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/streams/ai-stream.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/streams/stream-data.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/streams/openai-stream.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/util/consume-stream.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/rsc/streamable-value/streamable-value.ts","/turbopack/[project]/node_modules/.pnpm/ai@3.3.17_openai@4.56.0_zod@3.23.8__react@18.3.1_sswr@2.1.0_svelte@4.2.19__svelte@4.2.19_vue@_wrejqlrui2gdliogi74j4qbrna/node_modules/ai/rsc/streamable-value/create-streamable-value.ts"],"sourcesContent":["import * as jsondiffpatch from 'jsondiffpatch';\nimport { AsyncLocalStorage } from 'node:async_hooks';\nimport { createResolvablePromise } from '../util/create-resolvable-promise';\nimport { isFunction } from '../util/is-function';\nimport type {\n  AIProvider,\n  InferAIState,\n  InternalAIStateStorageOptions,\n  MutableAIState,\n  ValueOrUpdater,\n} from './types';\n\n// It is possible that multiple AI requests get in concurrently, for different\n// AI instances. So ALS is necessary here for a simpler API.\nconst asyncAIStateStorage = new AsyncLocalStorage<{\n  currentState: any;\n  originalState: any;\n  sealed: boolean;\n  options: InternalAIStateStorageOptions;\n  mutationDeltaPromise?: Promise<any>;\n  mutationDeltaResolve?: (v: any) => void;\n}>();\n\nfunction getAIStateStoreOrThrow(message: string) {\n  const store = asyncAIStateStorage.getStore();\n  if (!store) {\n    throw new Error(message);\n  }\n  return store;\n}\n\nexport function withAIState<S, T>(\n  { state, options }: { state: S; options: InternalAIStateStorageOptions },\n  fn: () => T,\n): T {\n  return asyncAIStateStorage.run(\n    {\n      currentState: state,\n      originalState: state,\n      sealed: false,\n      options,\n    },\n    fn,\n  );\n}\n\nexport function getAIStateDeltaPromise() {\n  const store = getAIStateStoreOrThrow('Internal error occurred.');\n  return store.mutationDeltaPromise;\n}\n\n// Internal method. This will be called after the AI Action has been returned\n// and you can no longer call `getMutableAIState()` inside any async callbacks\n// created by that Action.\nexport function sealMutableAIState() {\n  const store = getAIStateStoreOrThrow('Internal error occurred.');\n  store.sealed = true;\n}\n\n/**\n * Get the current AI state.\n * If `key` is provided, it will return the value of the specified key in the\n * AI state, if it's an object. If it's not an object, it will throw an error.\n *\n * @example const state = getAIState() // Get the entire AI state\n * @example const field = getAIState('key') // Get the value of the key\n */\nfunction getAIState<AI extends AIProvider = any>(): Readonly<\n  InferAIState<AI, any>\n>;\nfunction getAIState<AI extends AIProvider = any>(\n  key: keyof InferAIState<AI, any>,\n): Readonly<InferAIState<AI, any>[typeof key]>;\nfunction getAIState<AI extends AIProvider = any>(\n  ...args: [] | [key: keyof InferAIState<AI, any>]\n) {\n  const store = getAIStateStoreOrThrow(\n    '`getAIState` must be called within an AI Action.',\n  );\n\n  if (args.length > 0) {\n    const key = args[0];\n    if (typeof store.currentState !== 'object') {\n      throw new Error(\n        `You can't get the \"${String(\n          key,\n        )}\" field from the AI state because it's not an object.`,\n      );\n    }\n    return store.currentState[key as keyof typeof store.currentState];\n  }\n\n  return store.currentState;\n}\n\n/**\n * Get the mutable AI state. Note that you must call `.done()` when finishing\n * updating the AI state.\n *\n * @example\n * ```tsx\n * const state = getMutableAIState()\n * state.update({ ...state.get(), key: 'value' })\n * state.update((currentState) => ({ ...currentState, key: 'value' }))\n * state.done()\n * ```\n *\n * @example\n * ```tsx\n * const state = getMutableAIState()\n * state.done({ ...state.get(), key: 'value' }) // Done with a new state\n * ```\n */\nfunction getMutableAIState<AI extends AIProvider = any>(): MutableAIState<\n  InferAIState<AI, any>\n>;\nfunction getMutableAIState<AI extends AIProvider = any>(\n  key: keyof InferAIState<AI, any>,\n): MutableAIState<InferAIState<AI, any>[typeof key]>;\nfunction getMutableAIState<AI extends AIProvider = any>(\n  ...args: [] | [key: keyof InferAIState<AI, any>]\n) {\n  type AIState = InferAIState<AI, any>;\n  type AIStateWithKey = typeof args extends [key: keyof AIState]\n    ? AIState[(typeof args)[0]]\n    : AIState;\n  type NewStateOrUpdater = ValueOrUpdater<AIStateWithKey>;\n\n  const store = getAIStateStoreOrThrow(\n    '`getMutableAIState` must be called within an AI Action.',\n  );\n\n  if (store.sealed) {\n    throw new Error(\n      \"`getMutableAIState` must be called before returning from an AI Action. Please move it to the top level of the Action's function body.\",\n    );\n  }\n\n  if (!store.mutationDeltaPromise) {\n    const { promise, resolve } = createResolvablePromise();\n    store.mutationDeltaPromise = promise;\n    store.mutationDeltaResolve = resolve;\n  }\n\n  function doUpdate(newState: NewStateOrUpdater, done: boolean) {\n    if (args.length > 0) {\n      if (typeof store.currentState !== 'object') {\n        const key = args[0];\n        throw new Error(\n          `You can't modify the \"${String(\n            key,\n          )}\" field of the AI state because it's not an object.`,\n        );\n      }\n    }\n\n    if (isFunction(newState)) {\n      if (args.length > 0) {\n        store.currentState[args[0]] = newState(store.currentState[args[0]]);\n      } else {\n        store.currentState = newState(store.currentState);\n      }\n    } else {\n      if (args.length > 0) {\n        store.currentState[args[0]] = newState;\n      } else {\n        store.currentState = newState;\n      }\n    }\n\n    store.options.onSetAIState?.({\n      key: args.length > 0 ? args[0] : undefined,\n      state: store.currentState,\n      done,\n    });\n  }\n\n  const mutableState = {\n    get: () => {\n      if (args.length > 0) {\n        const key = args[0];\n        if (typeof store.currentState !== 'object') {\n          throw new Error(\n            `You can't get the \"${String(\n              key,\n            )}\" field from the AI state because it's not an object.`,\n          );\n        }\n        return store.currentState[key] as Readonly<AIStateWithKey>;\n      }\n\n      return store.currentState as Readonly<AIState>;\n    },\n    update: function update(newAIState: NewStateOrUpdater) {\n      doUpdate(newAIState, false);\n    },\n    done: function done(...doneArgs: [] | [NewStateOrUpdater]) {\n      if (doneArgs.length > 0) {\n        doUpdate(doneArgs[0] as NewStateOrUpdater, true);\n      }\n\n      const delta = jsondiffpatch.diff(store.originalState, store.currentState);\n      store.mutationDeltaResolve!(delta);\n    },\n  };\n\n  return mutableState;\n}\n\nexport { getAIState, getMutableAIState };\n","/**\n * Creates a Promise with externally accessible resolve and reject functions.\n *\n * @template T - The type of the value that the Promise will resolve to.\n * @returns An object containing:\n *   - promise: A Promise that can be resolved or rejected externally.\n *   - resolve: A function to resolve the Promise with a value of type T.\n *   - reject: A function to reject the Promise with an error.\n */\nexport function createResolvablePromise<T = any>(): {\n  promise: Promise<T>;\n  resolve: (value: T) => void;\n  reject: (error: unknown) => void;\n} {\n  let resolve: (value: T) => void;\n  let reject: (error: unknown) => void;\n\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return {\n    promise,\n    resolve: resolve!,\n    reject: reject!,\n  };\n}\n","/**\n * Checks if the given value is a function.\n *\n * @param {unknown} value - The value to check.\n * @returns {boolean} True if the value is a function, false otherwise.\n */\nexport const isFunction = (value: unknown): value is Function =>\n  typeof value === 'function';\n","// This file provides the AI context to all AI Actions via AsyncLocalStorage.\n\nimport * as React from 'react';\nimport { InternalAIProvider } from './rsc-shared.mjs';\nimport {\n  withAIState,\n  getAIStateDeltaPromise,\n  sealMutableAIState,\n} from './ai-state';\nimport type {\n  ServerWrappedActions,\n  AIAction,\n  AIActions,\n  AIProvider,\n  InternalAIStateStorageOptions,\n  OnSetAIState,\n  OnGetUIState,\n} from './types';\n\nasync function innerAction<T>(\n  {\n    action,\n    options,\n  }: { action: AIAction; options: InternalAIStateStorageOptions },\n  state: T,\n  ...args: unknown[]\n) {\n  'use server';\n  return await withAIState(\n    {\n      state,\n      options,\n    },\n    async () => {\n      const result = await action(...args);\n      sealMutableAIState();\n      return [getAIStateDeltaPromise() as Promise<T>, result];\n    },\n  );\n}\n\nfunction wrapAction<T = unknown>(\n  action: AIAction,\n  options: InternalAIStateStorageOptions,\n) {\n  return innerAction.bind(null, { action, options }) as AIAction<T>;\n}\n\nexport function createAI<\n  AIState = any,\n  UIState = any,\n  Actions extends AIActions = {},\n>({\n  actions,\n  initialAIState,\n  initialUIState,\n\n  onSetAIState,\n  onGetUIState,\n}: {\n  actions: Actions;\n  initialAIState?: AIState;\n  initialUIState?: UIState;\n\n  /**\n   * This function is called whenever the AI state is updated by an Action.\n   * You can use this to persist the AI state to a database, or to send it to a\n   * logging service.\n   */\n  onSetAIState?: OnSetAIState<AIState>;\n\n  /**\n   * This function is used to retrieve the UI state based on the AI state.\n   * For example, to render the initial UI state based on a given AI state, or\n   * to sync the UI state when the application is already loaded.\n   *\n   * If returning `undefined`, the client side UI state will not be updated.\n   *\n   * This function must be annotated with the `\"use server\"` directive.\n   *\n   * @example\n   * ```tsx\n   * onGetUIState: async () => {\n   *   'use server';\n   *\n   *   const currentAIState = getAIState();\n   *   const externalAIState = await loadAIStateFromDatabase();\n   *\n   *   if (currentAIState === externalAIState) return undefined;\n   *\n   *   // Update current AI state and return the new UI state\n   *   const state = getMutableAIState()\n   *   state.done(externalAIState)\n   *\n   *   return <div>...</div>;\n   * }\n   * ```\n   */\n  onGetUIState?: OnGetUIState<UIState>;\n}) {\n  // Wrap all actions with our HoC.\n  const wrappedActions: ServerWrappedActions = {};\n  for (const name in actions) {\n    wrappedActions[name] = wrapAction(actions[name], {\n      onSetAIState,\n    });\n  }\n\n  const wrappedSyncUIState = onGetUIState\n    ? wrapAction(onGetUIState, {})\n    : undefined;\n\n  const AI: AIProvider<AIState, UIState, Actions> = async props => {\n    if ('useState' in React) {\n      // This file must be running on the React Server layer.\n      // Ideally we should be using `import \"server-only\"` here but we can have a\n      // more customized error message with this implementation.\n      throw new Error(\n        'This component can only be used inside Server Components.',\n      );\n    }\n\n    let uiState = props.initialUIState ?? initialUIState;\n    let aiState = props.initialAIState ?? initialAIState;\n    let aiStateDelta = undefined;\n\n    if (wrappedSyncUIState) {\n      const [newAIStateDelta, newUIState] = await wrappedSyncUIState(aiState);\n      if (newUIState !== undefined) {\n        aiStateDelta = newAIStateDelta;\n        uiState = newUIState;\n      }\n    }\n\n    return (\n      <InternalAIProvider\n        wrappedActions={wrappedActions}\n        wrappedSyncUIState={wrappedSyncUIState}\n        initialUIState={uiState}\n        initialAIState={aiState}\n        initialAIStatePatch={aiStateDelta}\n      >\n        {props.children}\n      </InternalAIProvider>\n    );\n  };\n\n  return AI;\n}\n","import { LanguageModelV1 } from '@ai-sdk/provider';\nimport { safeParseJSON } from '@ai-sdk/provider-utils';\nimport { ReactNode } from 'react';\nimport { z } from 'zod';\nimport { CallSettings } from '../../core/prompt/call-settings';\nimport { convertToLanguageModelPrompt } from '../../core/prompt/convert-to-language-model-prompt';\nimport { prepareCallSettings } from '../../core/prompt/prepare-call-settings';\nimport { prepareToolsAndToolChoice } from '../../core/prompt/prepare-tools-and-tool-choice';\nimport { Prompt } from '../../core/prompt/prompt';\nimport { validatePrompt } from '../../core/prompt/validate-prompt';\nimport { CallWarning, CoreToolChoice, FinishReason } from '../../core/types';\nimport {\n  CompletionTokenUsage,\n  calculateCompletionTokenUsage,\n} from '../../core/types/token-usage';\nimport { InvalidToolArgumentsError } from '../../errors/invalid-tool-arguments-error';\nimport { NoSuchToolError } from '../../errors/no-such-tool-error';\nimport { createResolvablePromise } from '../../util/create-resolvable-promise';\nimport { isAsyncGenerator } from '../../util/is-async-generator';\nimport { isGenerator } from '../../util/is-generator';\nimport { retryWithExponentialBackoff } from '../../util/retry-with-exponential-backoff';\nimport { createStreamableUI } from '../streamable-ui/create-streamable-ui';\n\ntype Streamable = ReactNode | Promise<ReactNode>;\n\ntype Renderer<T extends Array<any>> = (\n  ...args: T\n) =>\n  | Streamable\n  | Generator<Streamable, Streamable, void>\n  | AsyncGenerator<Streamable, Streamable, void>;\n\ntype RenderTool<PARAMETERS extends z.ZodTypeAny = any> = {\n  description?: string;\n  parameters: PARAMETERS;\n  generate?: Renderer<\n    [\n      z.infer<PARAMETERS>,\n      {\n        toolName: string;\n        toolCallId: string;\n      },\n    ]\n  >;\n};\n\ntype RenderText = Renderer<\n  [\n    {\n      /**\n       * The full text content from the model so far.\n       */\n      content: string;\n\n      /**\n       * The new appended text content from the model since the last `text` call.\n       */\n      delta: string;\n\n      /**\n       * Whether the model is done generating text.\n       * If `true`, the `content` will be the final output and this call will be the last.\n       */\n      done: boolean;\n    },\n  ]\n>;\n\ntype RenderResult = {\n  value: ReactNode;\n} & Awaited<ReturnType<LanguageModelV1['doStream']>>;\n\nconst defaultTextRenderer: RenderText = ({ content }: { content: string }) =>\n  content;\n\n/**\n * `streamUI` is a helper function to create a streamable UI from LLMs.\n */\nexport async function streamUI<\n  TOOLS extends { [name: string]: z.ZodTypeAny } = {},\n>({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  initial,\n  text,\n  onFinish,\n  ...settings\n}: CallSettings &\n  Prompt & {\n    /**\n     * The language model to use.\n     */\n    model: LanguageModelV1;\n\n    /**\n     * The tools that the model can call. The model needs to support calling tools.\n     */\n    tools?: {\n      [name in keyof TOOLS]: RenderTool<TOOLS[name]>;\n    };\n\n    /**\n     * The tool choice strategy. Default: 'auto'.\n     */\n    toolChoice?: CoreToolChoice<TOOLS>;\n\n    text?: RenderText;\n    initial?: ReactNode;\n    /**\n     * Callback that is called when the LLM response and the final object validation are finished.\n     */\n    onFinish?: (event: {\n      /**\n       * The reason why the generation finished.\n       */\n      finishReason: FinishReason;\n      /**\n       * The token usage of the generated response.\n       */\n      usage: CompletionTokenUsage;\n      /**\n       * The final ui node that was generated.\n       */\n      value: ReactNode;\n      /**\n       * Warnings from the model provider (e.g. unsupported settings)\n       */\n      warnings?: CallWarning[];\n      /**\n       * Optional raw response data.\n       */\n      rawResponse?: {\n        /**\n         * Response headers.\n         */\n        headers?: Record<string, string>;\n      };\n    }) => Promise<void> | void;\n  }): Promise<RenderResult> {\n  // TODO: Remove these errors after the experimental phase.\n  if (typeof model === 'string') {\n    throw new Error(\n      '`model` cannot be a string in `streamUI`. Use the actual model instance instead.',\n    );\n  }\n  if ('functions' in settings) {\n    throw new Error(\n      '`functions` is not supported in `streamUI`, use `tools` instead.',\n    );\n  }\n  if ('provider' in settings) {\n    throw new Error(\n      '`provider` is no longer needed in `streamUI`. Use `model` instead.',\n    );\n  }\n  if (tools) {\n    for (const [name, tool] of Object.entries(tools)) {\n      if ('render' in tool) {\n        throw new Error(\n          'Tool definition in `streamUI` should not have `render` property. Use `generate` instead. Found in tool: ' +\n            name,\n        );\n      }\n    }\n  }\n\n  const ui = createStreamableUI(initial);\n\n  // The default text renderer just returns the content as string.\n  const textRender = text || defaultTextRenderer;\n\n  let finished: Promise<void> | undefined;\n\n  async function render({\n    args,\n    renderer,\n    streamableUI,\n    isLastCall = false,\n  }: {\n    renderer: undefined | Renderer<any>;\n    args: [payload: any] | [payload: any, options: any];\n    streamableUI: ReturnType<typeof createStreamableUI>;\n    isLastCall?: boolean;\n  }) {\n    if (!renderer) return;\n\n    // create a promise that will be resolved when the render call is finished.\n    // it is appended to the `finished` promise chain to ensure the render call\n    // is finished before the next render call starts.\n    const renderFinished = createResolvablePromise<void>();\n    finished = finished\n      ? finished.then(() => renderFinished.promise)\n      : renderFinished.promise;\n\n    const rendererResult = renderer(...args);\n\n    if (isAsyncGenerator(rendererResult) || isGenerator(rendererResult)) {\n      while (true) {\n        const { done, value } = await rendererResult.next();\n        const node = await value;\n\n        if (isLastCall && done) {\n          streamableUI.done(node);\n        } else {\n          streamableUI.update(node);\n        }\n\n        if (done) break;\n      }\n    } else {\n      const node = await rendererResult;\n\n      if (isLastCall) {\n        streamableUI.done(node);\n      } else {\n        streamableUI.update(node);\n      }\n    }\n\n    // resolve the promise to signal that the render call is finished\n    renderFinished.resolve(undefined);\n  }\n\n  const retry = retryWithExponentialBackoff({ maxRetries });\n  const validatedPrompt = validatePrompt({ system, prompt, messages });\n  const result = await retry(async () =>\n    model.doStream({\n      mode: {\n        type: 'regular',\n        ...prepareToolsAndToolChoice({ tools, toolChoice }),\n      },\n      ...prepareCallSettings(settings),\n      inputFormat: validatedPrompt.type,\n      prompt: await convertToLanguageModelPrompt({\n        prompt: validatedPrompt,\n        modelSupportsImageUrls: model.supportsImageUrls,\n      }),\n      abortSignal,\n      headers,\n    }),\n  );\n\n  // For the stream and consume it asynchronously:\n  const [stream, forkedStream] = result.stream.tee();\n  (async () => {\n    try {\n      let content = '';\n      let hasToolCall = false;\n\n      const reader = forkedStream.getReader();\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n\n        switch (value.type) {\n          case 'text-delta': {\n            content += value.textDelta;\n            render({\n              renderer: textRender,\n              args: [{ content, done: false, delta: value.textDelta }],\n              streamableUI: ui,\n            });\n            break;\n          }\n\n          case 'tool-call-delta': {\n            hasToolCall = true;\n            break;\n          }\n\n          case 'tool-call': {\n            const toolName = value.toolName as keyof TOOLS & string;\n\n            if (!tools) {\n              throw new NoSuchToolError({ toolName });\n            }\n\n            const tool = tools[toolName];\n            if (!tool) {\n              throw new NoSuchToolError({\n                toolName,\n                availableTools: Object.keys(tools),\n              });\n            }\n\n            hasToolCall = true;\n            const parseResult = safeParseJSON({\n              text: value.args,\n              schema: tool.parameters,\n            });\n\n            if (parseResult.success === false) {\n              throw new InvalidToolArgumentsError({\n                toolName,\n                toolArgs: value.args,\n                cause: parseResult.error,\n              });\n            }\n\n            render({\n              renderer: tool.generate,\n              args: [\n                parseResult.value,\n                {\n                  toolName,\n                  toolCallId: value.toolCallId,\n                },\n              ],\n              streamableUI: ui,\n              isLastCall: true,\n            });\n\n            break;\n          }\n\n          case 'error': {\n            throw value.error;\n          }\n\n          case 'finish': {\n            onFinish?.({\n              finishReason: value.finishReason,\n              usage: calculateCompletionTokenUsage(value.usage),\n              value: ui.value,\n              warnings: result.warnings,\n              rawResponse: result.rawResponse,\n            });\n          }\n        }\n      }\n\n      if (!hasToolCall) {\n        render({\n          renderer: textRender,\n          args: [{ content, done: true }],\n          streamableUI: ui,\n          isLastCall: true,\n        });\n      }\n\n      await finished;\n    } catch (error) {\n      // During the stream rendering, we don't want to throw the error to the\n      // parent scope but only let the React's error boundary to catch it.\n      ui.error(error);\n    }\n  })();\n\n  return {\n    ...result,\n    stream,\n    value: ui.value,\n  };\n}\n","import {\n  LanguageModelV1ImagePart,\n  LanguageModelV1Message,\n  LanguageModelV1Prompt,\n  LanguageModelV1TextPart,\n} from '@ai-sdk/provider';\nimport { getErrorMessage } from '@ai-sdk/provider-utils';\nimport { download } from '../../util/download';\nimport { CoreMessage } from '../prompt/message';\nimport { detectImageMimeType } from '../util/detect-image-mimetype';\nimport { ImagePart, TextPart } from './content-part';\nimport { convertDataContentToUint8Array } from './data-content';\nimport { InvalidMessageRoleError } from './invalid-message-role-error';\nimport { ValidatedPrompt } from './validate-prompt';\n\nexport async function convertToLanguageModelPrompt({\n  prompt,\n  modelSupportsImageUrls = true,\n  downloadImplementation = download,\n}: {\n  prompt: ValidatedPrompt;\n  modelSupportsImageUrls: boolean | undefined;\n  downloadImplementation?: typeof download;\n}): Promise<LanguageModelV1Prompt> {\n  const languageModelMessages: LanguageModelV1Prompt = [];\n\n  if (prompt.system != null) {\n    languageModelMessages.push({ role: 'system', content: prompt.system });\n  }\n\n  const downloadedImages =\n    modelSupportsImageUrls || prompt.messages == null\n      ? null\n      : await downloadImages(prompt.messages, downloadImplementation);\n\n  const promptType = prompt.type;\n  switch (promptType) {\n    case 'prompt': {\n      languageModelMessages.push({\n        role: 'user',\n        content: [{ type: 'text', text: prompt.prompt }],\n      });\n      break;\n    }\n\n    case 'messages': {\n      languageModelMessages.push(\n        ...prompt.messages.map(\n          (message): LanguageModelV1Message =>\n            convertToLanguageModelMessage(message, downloadedImages),\n        ),\n      );\n      break;\n    }\n\n    default: {\n      const _exhaustiveCheck: never = promptType;\n      throw new Error(`Unsupported prompt type: ${_exhaustiveCheck}`);\n    }\n  }\n\n  return languageModelMessages;\n}\n\n/**\n * Convert a CoreMessage to a LanguageModelV1Message.\n *\n * @param message The CoreMessage to convert.\n * @param downloadedImages A map of image URLs to their downloaded data. Only\n *   available if the model does not support image URLs, null otherwise.\n */\nexport function convertToLanguageModelMessage(\n  message: CoreMessage,\n  downloadedImages: Record<\n    string,\n    { mimeType: string | undefined; data: Uint8Array }\n  > | null,\n): LanguageModelV1Message {\n  const role = message.role;\n  switch (role) {\n    case 'system': {\n      return {\n        role: 'system',\n        content: message.content,\n        providerMetadata: message.experimental_providerMetadata,\n      };\n    }\n\n    case 'user': {\n      if (typeof message.content === 'string') {\n        return {\n          role: 'user',\n          content: [{ type: 'text', text: message.content }],\n          providerMetadata: message.experimental_providerMetadata,\n        };\n      }\n\n      return {\n        role: 'user',\n        content: message.content.map(\n          (part): LanguageModelV1TextPart | LanguageModelV1ImagePart => {\n            switch (part.type) {\n              case 'text': {\n                return {\n                  type: 'text',\n                  text: part.text,\n                  providerMetadata: part.experimental_providerMetadata,\n                };\n              }\n\n              case 'image': {\n                if (part.image instanceof URL) {\n                  if (downloadedImages == null) {\n                    return {\n                      type: 'image',\n                      image: part.image,\n                      mimeType: part.mimeType,\n                      providerMetadata: part.experimental_providerMetadata,\n                    };\n                  } else {\n                    const downloadedImage =\n                      downloadedImages[part.image.toString()];\n                    return {\n                      type: 'image',\n                      image: downloadedImage.data,\n                      mimeType: part.mimeType ?? downloadedImage.mimeType,\n                      providerMetadata: part.experimental_providerMetadata,\n                    };\n                  }\n                }\n\n                // try to convert string image parts to urls\n                if (typeof part.image === 'string') {\n                  try {\n                    const url = new URL(part.image);\n\n                    switch (url.protocol) {\n                      case 'http:':\n                      case 'https:': {\n                        if (downloadedImages == null) {\n                          return {\n                            type: 'image',\n                            image: url,\n                            mimeType: part.mimeType,\n                            providerMetadata:\n                              part.experimental_providerMetadata,\n                          };\n                        } else {\n                          const downloadedImage = downloadedImages[part.image];\n                          return {\n                            type: 'image',\n                            image: downloadedImage.data,\n                            mimeType: part.mimeType ?? downloadedImage.mimeType,\n                            providerMetadata:\n                              part.experimental_providerMetadata,\n                          };\n                        }\n                      }\n                      case 'data:': {\n                        try {\n                          const [header, base64Content] = part.image.split(',');\n                          const mimeType = header.split(';')[0].split(':')[1];\n\n                          if (mimeType == null || base64Content == null) {\n                            throw new Error('Invalid data URL format');\n                          }\n\n                          return {\n                            type: 'image',\n                            image:\n                              convertDataContentToUint8Array(base64Content),\n                            mimeType,\n                            providerMetadata:\n                              part.experimental_providerMetadata,\n                          };\n                        } catch (error) {\n                          throw new Error(\n                            `Error processing data URL: ${getErrorMessage(\n                              message,\n                            )}`,\n                          );\n                        }\n                      }\n                      default: {\n                        throw new Error(\n                          `Unsupported URL protocol: ${url.protocol}`,\n                        );\n                      }\n                    }\n                  } catch (_ignored) {\n                    // not a URL\n                  }\n                }\n\n                const imageUint8 = convertDataContentToUint8Array(part.image);\n\n                return {\n                  type: 'image',\n                  image: imageUint8,\n                  mimeType: part.mimeType ?? detectImageMimeType(imageUint8),\n                  providerMetadata: part.experimental_providerMetadata,\n                };\n              }\n            }\n          },\n        ),\n        providerMetadata: message.experimental_providerMetadata,\n      };\n    }\n\n    case 'assistant': {\n      if (typeof message.content === 'string') {\n        return {\n          role: 'assistant',\n          content: [{ type: 'text', text: message.content }],\n          providerMetadata: message.experimental_providerMetadata,\n        };\n      }\n\n      return {\n        role: 'assistant',\n        content: message.content.filter(\n          // remove empty text parts:\n          part => part.type !== 'text' || part.text !== '',\n        ),\n        providerMetadata: message.experimental_providerMetadata,\n      };\n    }\n\n    case 'tool': {\n      return {\n        role: 'tool',\n        content: message.content.map(part => ({\n          type: 'tool-result',\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          result: part.result,\n          providerMetadata: part.experimental_providerMetadata,\n        })),\n        providerMetadata: message.experimental_providerMetadata,\n      };\n    }\n\n    default: {\n      const _exhaustiveCheck: never = role;\n      throw new InvalidMessageRoleError({ role: _exhaustiveCheck });\n    }\n  }\n}\n\nasync function downloadImages(\n  messages: CoreMessage[],\n  downloadImplementation: typeof download,\n): Promise<Record<string, { mimeType: string | undefined; data: Uint8Array }>> {\n  const urls = messages\n    .filter(message => message.role === 'user')\n    .map(message => message.content)\n    .filter((content): content is Array<TextPart | ImagePart> =>\n      Array.isArray(content),\n    )\n    .flat()\n    .filter((part): part is ImagePart => part.type === 'image')\n    .map(part => part.image)\n    .map(part =>\n      // support string urls in image parts:\n      typeof part === 'string' &&\n      (part.startsWith('http:') || part.startsWith('https:'))\n        ? new URL(part)\n        : part,\n    )\n    .filter((image): image is URL => image instanceof URL);\n\n  // download images in parallel:\n  const downloadedImages = await Promise.all(\n    urls.map(async url => ({\n      url,\n      data: await downloadImplementation({ url }),\n    })),\n  );\n\n  return Object.fromEntries(\n    downloadedImages.map(({ url, data }) => [url.toString(), data]),\n  );\n}\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_DownloadError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class DownloadError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly url: string;\n  readonly statusCode?: number;\n  readonly statusText?: string;\n\n  constructor({\n    url,\n    statusCode,\n    statusText,\n    cause,\n    message = cause == null\n      ? `Failed to download ${url}: ${statusCode} ${statusText}`\n      : `Failed to download ${url}: ${cause}`,\n  }: {\n    url: string;\n    statusCode?: number;\n    statusText?: string;\n    message?: string;\n    cause?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.url = url;\n    this.statusCode = statusCode;\n    this.statusText = statusText;\n  }\n\n  static isInstance(error: unknown): error is DownloadError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isDownloadError(error: unknown): error is DownloadError {\n    return (\n      error instanceof Error &&\n      error.name === name &&\n      typeof (error as DownloadError).url === 'string' &&\n      ((error as DownloadError).statusCode == null ||\n        typeof (error as DownloadError).statusCode === 'number') &&\n      ((error as DownloadError).statusText == null ||\n        typeof (error as DownloadError).statusText === 'string')\n    );\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      url: this.url,\n      statusCode: this.statusCode,\n      statusText: this.statusText,\n      cause: this.cause,\n    };\n  }\n}\n","import { DownloadError } from './download-error';\n\nexport async function download({\n  url,\n  fetchImplementation = fetch,\n}: {\n  url: URL;\n  fetchImplementation?: typeof fetch;\n}): Promise<{\n  data: Uint8Array;\n  mimeType: string | undefined;\n}> {\n  const urlText = url.toString();\n  try {\n    const response = await fetchImplementation(urlText);\n\n    if (!response.ok) {\n      throw new DownloadError({\n        url: urlText,\n        statusCode: response.status,\n        statusText: response.statusText,\n      });\n    }\n\n    return {\n      data: new Uint8Array(await response.arrayBuffer()),\n      mimeType: response.headers.get('content-type') ?? undefined,\n    };\n  } catch (error) {\n    if (DownloadError.isInstance(error)) {\n      throw error;\n    }\n\n    throw new DownloadError({ url: urlText, cause: error });\n  }\n}\n","const mimeTypeSignatures = [\n  { mimeType: 'image/gif' as const, bytes: [0x47, 0x49, 0x46] },\n  { mimeType: 'image/png' as const, bytes: [0x89, 0x50, 0x4e, 0x47] },\n  { mimeType: 'image/jpeg' as const, bytes: [0xff, 0xd8] },\n  { mimeType: 'image/webp' as const, bytes: [0x52, 0x49, 0x46, 0x46] },\n];\n\nexport function detectImageMimeType(\n  image: Uint8Array,\n): 'image/jpeg' | 'image/png' | 'image/gif' | 'image/webp' | undefined {\n  for (const { bytes, mimeType } of mimeTypeSignatures) {\n    if (\n      image.length >= bytes.length &&\n      bytes.every((byte, index) => image[index] === byte)\n    ) {\n      return mimeType;\n    }\n  }\n\n  return undefined;\n}\n","import {\n  convertBase64ToUint8Array,\n  convertUint8ArrayToBase64,\n} from '@ai-sdk/provider-utils';\nimport { InvalidDataContentError } from './invalid-data-content-error';\nimport { z } from 'zod';\n\n/**\nData content. Can either be a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer.\n */\nexport type DataContent = string | Uint8Array | ArrayBuffer | Buffer;\n\n/**\n@internal\n */\nexport const dataContentSchema: z.ZodType<DataContent> = z.union([\n  z.string(),\n  z.instanceof(Uint8Array),\n  z.instanceof(ArrayBuffer),\n  z.custom(\n    // Buffer might not be available in some environments such as CloudFlare:\n    (value: unknown): value is Buffer =>\n      globalThis.Buffer?.isBuffer(value) ?? false,\n    { message: 'Must be a Buffer' },\n  ),\n]);\n\n/**\nConverts data content to a base64-encoded string.\n\n@param content - Data content to convert.\n@returns Base64-encoded string.\n*/\nexport function convertDataContentToBase64String(content: DataContent): string {\n  if (typeof content === 'string') {\n    return content;\n  }\n\n  if (content instanceof ArrayBuffer) {\n    return convertUint8ArrayToBase64(new Uint8Array(content));\n  }\n\n  return convertUint8ArrayToBase64(content);\n}\n\n/**\nConverts data content to a Uint8Array.\n\n@param content - Data content to convert.\n@returns Uint8Array.\n */\nexport function convertDataContentToUint8Array(\n  content: DataContent,\n): Uint8Array {\n  if (content instanceof Uint8Array) {\n    return content;\n  }\n\n  if (typeof content === 'string') {\n    try {\n      return convertBase64ToUint8Array(content);\n    } catch (error) {\n      throw new InvalidDataContentError({\n        message:\n          'Invalid data content. Content string is not a base64-encoded media.',\n        content,\n        cause: error,\n      });\n    }\n  }\n\n  if (content instanceof ArrayBuffer) {\n    return new Uint8Array(content);\n  }\n\n  throw new InvalidDataContentError({ content });\n}\n\n/**\n * Converts a Uint8Array to a string of text.\n *\n * @param uint8Array - The Uint8Array to convert.\n * @returns The converted string.\n */\nexport function convertUint8ArrayToText(uint8Array: Uint8Array): string {\n  try {\n    return new TextDecoder().decode(uint8Array);\n  } catch (error) {\n    throw new Error('Error decoding Uint8Array to text');\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_InvalidDataContentError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidDataContentError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly content: unknown;\n\n  constructor({\n    content,\n    cause,\n    message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.`,\n  }: {\n    content: unknown;\n    cause?: unknown;\n    message?: string;\n  }) {\n    super({ name, message, cause });\n\n    this.content = content;\n  }\n\n  static isInstance(error: unknown): error is InvalidDataContentError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidDataContentError(\n    error: unknown,\n  ): error is InvalidDataContentError {\n    return (\n      error instanceof Error &&\n      error.name === name &&\n      (error as InvalidDataContentError).content != null\n    );\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      cause: this.cause,\n      content: this.content,\n    };\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_InvalidMessageRoleError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidMessageRoleError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly role: string;\n\n  constructor({\n    role,\n    message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".`,\n  }: {\n    role: string;\n    message?: string;\n  }) {\n    super({ name, message });\n\n    this.role = role;\n  }\n\n  static isInstance(error: unknown): error is InvalidMessageRoleError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidMessageRoleError(\n    error: unknown,\n  ): error is InvalidMessageRoleError {\n    return (\n      error instanceof Error &&\n      error.name === name &&\n      typeof (error as InvalidMessageRoleError).role === 'string'\n    );\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n\n      role: this.role,\n    };\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_InvalidArgumentError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidArgumentError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly parameter: string;\n  readonly value: unknown;\n\n  constructor({\n    parameter,\n    value,\n    message,\n  }: {\n    parameter: string;\n    value: unknown;\n    message: string;\n  }) {\n    super({\n      name,\n      message: `Invalid argument for parameter ${parameter}: ${message}`,\n    });\n\n    this.parameter = parameter;\n    this.value = value;\n  }\n\n  static isInstance(error: unknown): error is InvalidArgumentError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidArgumentError(error: unknown): error is InvalidArgumentError {\n    return (\n      error instanceof Error &&\n      error.name === name &&\n      typeof (error as InvalidArgumentError).parameter === 'string' &&\n      typeof (error as InvalidArgumentError).value === 'string'\n    );\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n\n      parameter: this.parameter,\n      value: this.value,\n    };\n  }\n}\n","import { InvalidArgumentError } from '../../errors/invalid-argument-error';\nimport { CallSettings } from './call-settings';\n\n/**\n * Validates call settings and sets default values.\n */\nexport function prepareCallSettings({\n  maxTokens,\n  temperature,\n  topP,\n  presencePenalty,\n  frequencyPenalty,\n  stopSequences,\n  seed,\n  maxRetries,\n}: CallSettings): CallSettings {\n  if (maxTokens != null) {\n    if (!Number.isInteger(maxTokens)) {\n      throw new InvalidArgumentError({\n        parameter: 'maxTokens',\n        value: maxTokens,\n        message: 'maxTokens must be an integer',\n      });\n    }\n\n    if (maxTokens < 1) {\n      throw new InvalidArgumentError({\n        parameter: 'maxTokens',\n        value: maxTokens,\n        message: 'maxTokens must be >= 1',\n      });\n    }\n  }\n\n  if (temperature != null) {\n    if (typeof temperature !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'temperature',\n        value: temperature,\n        message: 'temperature must be a number',\n      });\n    }\n  }\n\n  if (topP != null) {\n    if (typeof topP !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'topP',\n        value: topP,\n        message: 'topP must be a number',\n      });\n    }\n  }\n\n  if (presencePenalty != null) {\n    if (typeof presencePenalty !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'presencePenalty',\n        value: presencePenalty,\n        message: 'presencePenalty must be a number',\n      });\n    }\n  }\n\n  if (frequencyPenalty != null) {\n    if (typeof frequencyPenalty !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'frequencyPenalty',\n        value: frequencyPenalty,\n        message: 'frequencyPenalty must be a number',\n      });\n    }\n  }\n\n  if (seed != null) {\n    if (!Number.isInteger(seed)) {\n      throw new InvalidArgumentError({\n        parameter: 'seed',\n        value: seed,\n        message: 'seed must be an integer',\n      });\n    }\n  }\n\n  if (maxRetries != null) {\n    if (!Number.isInteger(maxRetries)) {\n      throw new InvalidArgumentError({\n        parameter: 'maxRetries',\n        value: maxRetries,\n        message: 'maxRetries must be an integer',\n      });\n    }\n\n    if (maxRetries < 0) {\n      throw new InvalidArgumentError({\n        parameter: 'maxRetries',\n        value: maxRetries,\n        message: 'maxRetries must be >= 0',\n      });\n    }\n  }\n\n  return {\n    maxTokens,\n    temperature: temperature ?? 0,\n    topP,\n    presencePenalty,\n    frequencyPenalty,\n    stopSequences:\n      stopSequences != null && stopSequences.length > 0\n        ? stopSequences\n        : undefined,\n    seed,\n    maxRetries: maxRetries ?? 2,\n  };\n}\n","import {\n  LanguageModelV1FunctionTool,\n  LanguageModelV1ToolChoice,\n} from '@ai-sdk/provider';\nimport { asSchema } from '@ai-sdk/ui-utils';\nimport { CoreTool } from '../tool/tool';\nimport { CoreToolChoice } from '../types/language-model';\nimport { isNonEmptyObject } from '../util/is-non-empty-object';\n\nexport function prepareToolsAndToolChoice<\n  TOOLS extends Record<string, CoreTool>,\n>({\n  tools,\n  toolChoice,\n}: {\n  tools: TOOLS | undefined;\n  toolChoice: CoreToolChoice<TOOLS> | undefined;\n}): {\n  tools: LanguageModelV1FunctionTool[] | undefined;\n  toolChoice: LanguageModelV1ToolChoice | undefined;\n} {\n  if (!isNonEmptyObject(tools)) {\n    return {\n      tools: undefined,\n      toolChoice: undefined,\n    };\n  }\n\n  return {\n    tools: Object.entries(tools).map(([name, tool]) => ({\n      type: 'function' as const,\n      name,\n      description: tool.description,\n      parameters: asSchema(tool.parameters).jsonSchema,\n    })),\n    toolChoice:\n      toolChoice == null\n        ? { type: 'auto' }\n        : typeof toolChoice === 'string'\n        ? { type: toolChoice }\n        : { type: 'tool' as const, toolName: toolChoice.toolName as string },\n  };\n}\n","export function isNonEmptyObject(\n  object: Record<string, unknown> | undefined | null,\n): object is Record<string, unknown> {\n  return object != null && Object.keys(object).length > 0;\n}\n","import { InvalidPromptError } from '@ai-sdk/provider';\nimport { safeValidateTypes } from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { CoreMessage, coreMessageSchema } from './message';\nimport { Prompt } from './prompt';\n\nexport type ValidatedPrompt =\n  | {\n      type: 'prompt';\n      prompt: string;\n      messages: undefined;\n      system?: string;\n    }\n  | {\n      type: 'messages';\n      prompt: undefined;\n      messages: CoreMessage[];\n      system?: string;\n    };\n\nexport function validatePrompt(prompt: Prompt): ValidatedPrompt {\n  if (prompt.prompt == null && prompt.messages == null) {\n    throw new InvalidPromptError({\n      prompt,\n      message: 'prompt or messages must be defined',\n    });\n  }\n\n  if (prompt.prompt != null && prompt.messages != null) {\n    throw new InvalidPromptError({\n      prompt,\n      message: 'prompt and messages cannot be defined at the same time',\n    });\n  }\n\n  // validate that system is a string\n  if (prompt.system != null && typeof prompt.system !== 'string') {\n    throw new InvalidPromptError({\n      prompt,\n      message: 'system must be a string',\n    });\n  }\n\n  // type: prompt\n  if (prompt.prompt != null) {\n    // validate that prompt is a string\n    if (typeof prompt.prompt !== 'string') {\n      throw new InvalidPromptError({\n        prompt,\n        message: 'prompt must be a string',\n      });\n    }\n\n    return {\n      type: 'prompt',\n      prompt: prompt.prompt,\n      messages: undefined,\n      system: prompt.system,\n    };\n  }\n\n  // type: messages\n  if (prompt.messages != null) {\n    const validationResult = safeValidateTypes({\n      value: prompt.messages,\n      schema: z.array(coreMessageSchema),\n    });\n\n    if (!validationResult.success) {\n      throw new InvalidPromptError({\n        prompt,\n        message: 'messages must be an array of CoreMessage',\n        cause: validationResult.error,\n      });\n    }\n\n    return {\n      type: 'messages',\n      prompt: undefined,\n      messages: prompt.messages!, // only possible case bc of checks above\n      system: prompt.system,\n    };\n  }\n\n  throw new Error('unreachable');\n}\n","import { z } from 'zod';\nimport { ProviderMetadata } from '../types';\nimport { providerMetadataSchema } from '../types/provider-metadata';\nimport {\n  ImagePart,\n  imagePartSchema,\n  TextPart,\n  textPartSchema,\n  ToolCallPart,\n  toolCallPartSchema,\n  ToolResultPart,\n  toolResultPartSchema,\n} from './content-part';\n\n/**\n A system message. It can contain system information.\n\n Note: using the \"system\" part of the prompt is strongly preferred\n to increase the resilience against prompt injection attacks,\n and because not all providers support several system messages.\n */\nexport type CoreSystemMessage = {\n  role: 'system';\n  content: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n};\n\nexport const coreSystemMessageSchema: z.ZodType<CoreSystemMessage> = z.object({\n  role: z.literal('system'),\n  content: z.string(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\n * @deprecated Use `CoreMessage` instead.\n */\nexport type ExperimentalMessage = CoreMessage;\n\n/**\nA user message. It can contain text or a combination of text and images.\n */\nexport type CoreUserMessage = {\n  role: 'user';\n  content: UserContent;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n};\n\nexport const coreUserMessageSchema: z.ZodType<CoreUserMessage> = z.object({\n  role: z.literal('user'),\n  content: z.union([\n    z.string(),\n    z.array(z.union([textPartSchema, imagePartSchema])),\n  ]),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\n * @deprecated Use `CoreUserMessage` instead.\n */\nexport type ExperimentalUserMessage = CoreUserMessage;\n\n/**\nContent of a user message. It can be a string or an array of text and image parts.\n */\nexport type UserContent = string | Array<TextPart | ImagePart>;\n\n/**\nAn assistant message. It can contain text, tool calls, or a combination of text and tool calls.\n */\nexport type CoreAssistantMessage = {\n  role: 'assistant';\n  content: AssistantContent;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n};\n\nexport const coreAssistantMessageSchema: z.ZodType<CoreAssistantMessage> =\n  z.object({\n    role: z.literal('assistant'),\n    content: z.union([\n      z.string(),\n      z.array(z.union([textPartSchema, toolCallPartSchema])),\n    ]),\n    experimental_providerMetadata: providerMetadataSchema.optional(),\n  });\n\n/**\n * @deprecated Use `CoreAssistantMessage` instead.\n */\nexport type ExperimentalAssistantMessage = CoreAssistantMessage;\n\n/**\nContent of an assistant message. It can be a string or an array of text and tool call parts.\n */\nexport type AssistantContent = string | Array<TextPart | ToolCallPart>;\n\n/**\nA tool message. It contains the result of one or more tool calls.\n */\nexport type CoreToolMessage = {\n  role: 'tool';\n  content: ToolContent;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n};\n\nexport const coreToolMessageSchema: z.ZodType<CoreToolMessage> = z.object({\n  role: z.literal('tool'),\n  content: z.array(toolResultPartSchema),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\n * @deprecated Use `CoreToolMessage` instead.\n */\nexport type ExperimentalToolMessage = CoreToolMessage;\n\n/**\nContent of a tool message. It is an array of tool result parts.\n */\nexport type ToolContent = Array<ToolResultPart>;\n\n/**\nA message that can be used in the `messages` field of a prompt.\nIt can be a user message, an assistant message, or a tool message.\n */\nexport type CoreMessage =\n  | CoreSystemMessage\n  | CoreUserMessage\n  | CoreAssistantMessage\n  | CoreToolMessage;\n\nexport const coreMessageSchema: z.ZodType<CoreMessage> = z.union([\n  coreSystemMessageSchema,\n  coreUserMessageSchema,\n  coreAssistantMessageSchema,\n  coreToolMessageSchema,\n]);\n","import { LanguageModelV1ProviderMetadata } from '@ai-sdk/provider';\nimport { z } from 'zod';\nimport { jsonValueSchema } from './json-value';\n\n/**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\nexport type ProviderMetadata = LanguageModelV1ProviderMetadata;\n\nexport const providerMetadataSchema: z.ZodType<ProviderMetadata> = z.record(\n  z.string(),\n  z.record(z.string(), jsonValueSchema),\n);\n","import { JSONValue } from '@ai-sdk/provider';\nimport { z } from 'zod';\n\nexport const jsonValueSchema: z.ZodType<JSONValue> = z.lazy(() =>\n  z.union([\n    z.null(),\n    z.string(),\n    z.number(),\n    z.boolean(),\n    z.record(z.string(), jsonValueSchema),\n    z.array(jsonValueSchema),\n  ]),\n);\n","import { z } from 'zod';\nimport {\n  ProviderMetadata,\n  providerMetadataSchema,\n} from '../types/provider-metadata';\nimport { DataContent, dataContentSchema } from './data-content';\n\n/**\nText content part of a prompt. It contains a string of text.\n */\nexport interface TextPart {\n  type: 'text';\n\n  /**\nThe text content.\n   */\n  text: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\nexport const textPartSchema: z.ZodType<TextPart> = z.object({\n  type: z.literal('text'),\n  text: z.string(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nImage content part of a prompt. It contains an image.\n */\nexport interface ImagePart {\n  type: 'image';\n\n  /**\nImage data. Can either be:\n\n- data: a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer\n- URL: a URL that points to the image\n   */\n  image: DataContent | URL;\n\n  /**\nOptional mime type of the image.\n   */\n  mimeType?: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\nexport const imagePartSchema: z.ZodType<ImagePart> = z.object({\n  type: z.literal('image'),\n  image: z.union([dataContentSchema, z.instanceof(URL)]),\n  mimeType: z.string().optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nTool call content part of a prompt. It contains a tool call (usually generated by the AI model).\n */\nexport interface ToolCallPart {\n  type: 'tool-call';\n\n  /**\nID of the tool call. This ID is used to match the tool call with the tool result.\n */\n  toolCallId: string;\n\n  /**\nName of the tool that is being called.\n */\n  toolName: string;\n\n  /**\nArguments of the tool call. This is a JSON-serializable object that matches the tool's input schema.\n   */\n  args: unknown;\n}\n\nexport const toolCallPartSchema: z.ZodType<ToolCallPart> = z.object({\n  type: z.literal('tool-call'),\n  toolCallId: z.string(),\n  toolName: z.string(),\n  args: z.unknown(),\n}) as z.ZodType<ToolCallPart>; // necessary bc args is optional on Zod type\n\n/**\nTool result content part of a prompt. It contains the result of the tool call with the matching ID.\n */\nexport interface ToolResultPart {\n  type: 'tool-result';\n\n  /**\nID of the tool call that this result is associated with.\n */\n  toolCallId: string;\n\n  /**\nName of the tool that generated this result.\n  */\n  toolName: string;\n\n  /**\nResult of the tool call. This is a JSON-serializable object.\n   */\n  result: unknown;\n\n  /**\nOptional flag if the result is an error or an error message.\n   */\n  isError?: boolean;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\nexport const toolResultPartSchema: z.ZodType<ToolResultPart> = z.object({\n  type: z.literal('tool-result'),\n  toolCallId: z.string(),\n  toolName: z.string(),\n  result: z.unknown(),\n  isError: z.boolean().optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n}) as z.ZodType<ToolResultPart>; // necessary bc result is optional on Zod type\n","/**\nRepresents the number of tokens used in a prompt and completion.\n */\nexport type CompletionTokenUsage = {\n  /**\nThe number of tokens used in the prompt.\n   */\n  promptTokens: number;\n\n  /**\nThe number of tokens used in the completion.\n */\n  completionTokens: number;\n\n  /**\nThe total number of tokens used (promptTokens + completionTokens).\n   */\n  totalTokens: number;\n};\n\n/**\nRepresents the number of tokens used in an embedding.\n */\nexport type EmbeddingTokenUsage = {\n  /**\nThe number of tokens used in the embedding.\n   */\n  tokens: number;\n};\n\nexport function calculateCompletionTokenUsage(usage: {\n  promptTokens: number;\n  completionTokens: number;\n}): CompletionTokenUsage {\n  return {\n    promptTokens: usage.promptTokens,\n    completionTokens: usage.completionTokens,\n    totalTokens: usage.promptTokens + usage.completionTokens,\n  };\n}\n","import { AISDKError, getErrorMessage } from '@ai-sdk/provider';\n\nconst name = 'AI_InvalidToolArgumentsError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidToolArgumentsError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly toolName: string;\n  readonly toolArgs: string;\n\n  constructor({\n    toolArgs,\n    toolName,\n    cause,\n    message = `Invalid arguments for tool ${toolName}: ${getErrorMessage(\n      cause,\n    )}`,\n  }: {\n    message?: string;\n    toolArgs: string;\n    toolName: string;\n    cause: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.toolArgs = toolArgs;\n    this.toolName = toolName;\n  }\n\n  static isInstance(error: unknown): error is InvalidToolArgumentsError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidToolArgumentsError(\n    error: unknown,\n  ): error is InvalidToolArgumentsError {\n    return (\n      error instanceof Error &&\n      error.name === name &&\n      typeof (error as InvalidToolArgumentsError).toolName === 'string' &&\n      typeof (error as InvalidToolArgumentsError).toolArgs === 'string'\n    );\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      cause: this.cause,\n      stack: this.stack,\n\n      toolName: this.toolName,\n      toolArgs: this.toolArgs,\n    };\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_NoSuchToolError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class NoSuchToolError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly toolName: string;\n  readonly availableTools: string[] | undefined;\n\n  constructor({\n    toolName,\n    availableTools = undefined,\n    message = `Model tried to call unavailable tool '${toolName}'. ${\n      availableTools === undefined\n        ? 'No tools are available.'\n        : `Available tools: ${availableTools.join(', ')}.`\n    }`,\n  }: {\n    toolName: string;\n    availableTools?: string[] | undefined;\n    message?: string;\n  }) {\n    super({ name, message });\n\n    this.toolName = toolName;\n    this.availableTools = availableTools;\n  }\n\n  static isInstance(error: unknown): error is NoSuchToolError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isNoSuchToolError(error: unknown): error is NoSuchToolError {\n    return (\n      error instanceof Error &&\n      error.name === name &&\n      'toolName' in error &&\n      error.toolName != undefined &&\n      typeof error.name === 'string'\n    );\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n\n      toolName: this.toolName,\n      availableTools: this.availableTools,\n    };\n  }\n}\n","export function isAsyncGenerator<T, TReturn, TNext>(\n  value: unknown,\n): value is AsyncGenerator<T, TReturn, TNext> {\n  return (\n    value != null && typeof value === 'object' && Symbol.asyncIterator in value\n  );\n}\n","export function isGenerator<T, TReturn, TNext>(\n  value: unknown,\n): value is Generator<T, TReturn, TNext> {\n  return value != null && typeof value === 'object' && Symbol.iterator in value;\n}\n","import { APICallError } from '@ai-sdk/provider';\nimport { getErrorMessage, isAbortError } from '@ai-sdk/provider-utils';\nimport { delay } from './delay';\nimport { RetryError } from './retry-error';\n\nexport type RetryFunction = <OUTPUT>(\n  fn: () => PromiseLike<OUTPUT>,\n) => PromiseLike<OUTPUT>;\n\n/**\nThe `retryWithExponentialBackoff` strategy retries a failed API call with an exponential backoff.\nYou can configure the maximum number of retries, the initial delay, and the backoff factor.\n */\nexport const retryWithExponentialBackoff =\n  ({\n    maxRetries = 2,\n    initialDelayInMs = 2000,\n    backoffFactor = 2,\n  } = {}): RetryFunction =>\n  async <OUTPUT>(f: () => PromiseLike<OUTPUT>) =>\n    _retryWithExponentialBackoff(f, {\n      maxRetries,\n      delayInMs: initialDelayInMs,\n      backoffFactor,\n    });\n\nasync function _retryWithExponentialBackoff<OUTPUT>(\n  f: () => PromiseLike<OUTPUT>,\n  {\n    maxRetries,\n    delayInMs,\n    backoffFactor,\n  }: { maxRetries: number; delayInMs: number; backoffFactor: number },\n  errors: unknown[] = [],\n): Promise<OUTPUT> {\n  try {\n    return await f();\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error; // don't retry when the request was aborted\n    }\n\n    if (maxRetries === 0) {\n      throw error; // don't wrap the error when retries are disabled\n    }\n\n    const errorMessage = getErrorMessage(error);\n    const newErrors = [...errors, error];\n    const tryNumber = newErrors.length;\n\n    if (tryNumber > maxRetries) {\n      throw new RetryError({\n        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n        reason: 'maxRetriesExceeded',\n        errors: newErrors,\n      });\n    }\n\n    if (\n      error instanceof Error &&\n      APICallError.isAPICallError(error) &&\n      error.isRetryable === true &&\n      tryNumber <= maxRetries\n    ) {\n      await delay(delayInMs);\n      return _retryWithExponentialBackoff(\n        f,\n        { maxRetries, delayInMs: backoffFactor * delayInMs, backoffFactor },\n        newErrors,\n      );\n    }\n\n    if (tryNumber === 1) {\n      throw error; // don't wrap the error when a non-retryable error occurs on the first try\n    }\n\n    throw new RetryError({\n      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n      reason: 'errorNotRetryable',\n      errors: newErrors,\n    });\n  }\n}\n","export async function delay(delayInMs?: number): Promise<void> {\n  return delayInMs === undefined\n    ? Promise.resolve()\n    : new Promise(resolve => setTimeout(resolve, delayInMs));\n}\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_RetryError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport type RetryErrorReason =\n  | 'maxRetriesExceeded'\n  | 'errorNotRetryable'\n  | 'abort';\n\nexport class RetryError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  // note: property order determines debugging output\n  readonly reason: RetryErrorReason;\n  readonly lastError: unknown;\n  readonly errors: Array<unknown>;\n\n  constructor({\n    message,\n    reason,\n    errors,\n  }: {\n    message: string;\n    reason: RetryErrorReason;\n    errors: Array<unknown>;\n  }) {\n    super({ name, message });\n\n    this.reason = reason;\n    this.errors = errors;\n\n    // separate our last error to make debugging via log easier:\n    this.lastError = errors[errors.length - 1];\n  }\n\n  static isInstance(error: unknown): error is RetryError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isRetryError(error: unknown): error is RetryError {\n    return (\n      error instanceof Error &&\n      error.name === name &&\n      typeof (error as RetryError).reason === 'string' &&\n      Array.isArray((error as RetryError).errors)\n    );\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      reason: this.reason,\n      lastError: this.lastError,\n      errors: this.errors,\n    };\n  }\n}\n","/**\n * Warning time for notifying developers that a stream is hanging in dev mode\n * using a console.warn.\n */\nexport const HANGING_STREAM_WARNING_TIME_MS = 15 * 1000;\n","import React, { Suspense } from 'react';\nimport { createResolvablePromise } from '../../util/create-resolvable-promise';\n\n// Recursive type for the chunk.\ntype ChunkType =\n  | {\n      done: false;\n      value: React.ReactNode;\n      next: Promise<ChunkType>;\n      append?: boolean;\n    }\n  | {\n      done: true;\n      value: React.ReactNode;\n    };\n\n// Use single letter names for the variables to reduce the size of the RSC payload.\n// `R` for `Row`, `c` for `current`, `n` for `next`.\n// Note: Array construction is needed to access the name R.\nconst R = [\n  (async ({\n    c: current,\n    n: next,\n  }: {\n    c: React.ReactNode;\n    n: Promise<ChunkType>;\n  }) => {\n    const chunk = await next;\n\n    if (chunk.done) {\n      return chunk.value;\n    }\n\n    if (chunk.append) {\n      return (\n        <>\n          {current}\n          <Suspense fallback={chunk.value}>\n            <R c={chunk.value} n={chunk.next} />\n          </Suspense>\n        </>\n      );\n    }\n\n    return (\n      <Suspense fallback={chunk.value}>\n        <R c={chunk.value} n={chunk.next} />\n      </Suspense>\n    );\n  }) as unknown as React.FC<{\n    c: React.ReactNode;\n    n: Promise<ChunkType>;\n  }>,\n][0];\n\n/**\n * Creates a suspended chunk for React Server Components.\n *\n * This function generates a suspenseful React component that can be dynamically updated.\n * It's useful for streaming updates to the client in a React Server Components context.\n *\n * @param {React.ReactNode} initialValue - The initial value to render while the promise is pending.\n * @returns {Object} An object containing:\n *   - row: A React node that renders the suspenseful content.\n *   - resolve: A function to resolve the promise with a new value.\n *   - reject: A function to reject the promise with an error.\n */\nexport function createSuspendedChunk(initialValue: React.ReactNode): {\n  row: React.ReactNode;\n  resolve: (value: ChunkType) => void;\n  reject: (error: unknown) => void;\n} {\n  const { promise, resolve, reject } = createResolvablePromise<ChunkType>();\n\n  return {\n    row: (\n      <Suspense fallback={initialValue}>\n        <R c={initialValue} n={promise} />\n      </Suspense>\n    ),\n    resolve,\n    reject,\n  };\n}\n","import { HANGING_STREAM_WARNING_TIME_MS } from '../../util/constants';\nimport { createResolvablePromise } from '../../util/create-resolvable-promise';\nimport { createSuspendedChunk } from './create-suspended-chunk';\n\n// It's necessary to define the type manually here, otherwise TypeScript compiler\n// will not be able to infer the correct return type as it's circular.\ntype StreamableUIWrapper = {\n  /**\n   * The value of the streamable UI. This can be returned from a Server Action and received by the client.\n   */\n  readonly value: React.ReactNode;\n\n  /**\n   * This method updates the current UI node. It takes a new UI node and replaces the old one.\n   */\n  update(value: React.ReactNode): StreamableUIWrapper;\n\n  /**\n   * This method is used to append a new UI node to the end of the old one.\n   * Once appended a new UI node, the previous UI node cannot be updated anymore.\n   *\n   * @example\n   * ```jsx\n   * const ui = createStreamableUI(<div>hello</div>)\n   * ui.append(<div>world</div>)\n   *\n   * // The UI node will be:\n   * // <>\n   * //   <div>hello</div>\n   * //   <div>world</div>\n   * // </>\n   * ```\n   */\n  append(value: React.ReactNode): StreamableUIWrapper;\n\n  /**\n   * This method is used to signal that there is an error in the UI stream.\n   * It will be thrown on the client side and caught by the nearest error boundary component.\n   */\n  error(error: any): StreamableUIWrapper;\n\n  /**\n   * This method marks the UI node as finalized. You can either call it without any parameters or with a new UI node as the final state.\n   * Once called, the UI node cannot be updated or appended anymore.\n   *\n   * This method is always **required** to be called, otherwise the response will be stuck in a loading state.\n   */\n  done(...args: [React.ReactNode] | []): StreamableUIWrapper;\n};\n\n/**\n * Create a piece of changeable UI that can be streamed to the client.\n * On the client side, it can be rendered as a normal React node.\n */\nfunction createStreamableUI(initialValue?: React.ReactNode) {\n  let currentValue = initialValue;\n  let closed = false;\n  let { row, resolve, reject } = createSuspendedChunk(initialValue);\n\n  function assertStream(method: string) {\n    if (closed) {\n      throw new Error(method + ': UI stream is already closed.');\n    }\n  }\n\n  let warningTimeout: NodeJS.Timeout | undefined;\n  function warnUnclosedStream() {\n    if (process.env.NODE_ENV === 'development') {\n      if (warningTimeout) {\n        clearTimeout(warningTimeout);\n      }\n      warningTimeout = setTimeout(() => {\n        console.warn(\n          'The streamable UI has been slow to update. This may be a bug or a performance issue or you forgot to call `.done()`.',\n        );\n      }, HANGING_STREAM_WARNING_TIME_MS);\n    }\n  }\n  warnUnclosedStream();\n\n  const streamable: StreamableUIWrapper = {\n    value: row,\n    update(value: React.ReactNode) {\n      assertStream('.update()');\n\n      // There is no need to update the value if it's referentially equal.\n      if (value === currentValue) {\n        warnUnclosedStream();\n        return streamable;\n      }\n\n      const resolvable = createResolvablePromise();\n      currentValue = value;\n\n      resolve({ value: currentValue, done: false, next: resolvable.promise });\n      resolve = resolvable.resolve;\n      reject = resolvable.reject;\n\n      warnUnclosedStream();\n\n      return streamable;\n    },\n    append(value: React.ReactNode) {\n      assertStream('.append()');\n\n      const resolvable = createResolvablePromise();\n      currentValue = value;\n\n      resolve({ value, done: false, append: true, next: resolvable.promise });\n      resolve = resolvable.resolve;\n      reject = resolvable.reject;\n\n      warnUnclosedStream();\n\n      return streamable;\n    },\n    error(error: any) {\n      assertStream('.error()');\n\n      if (warningTimeout) {\n        clearTimeout(warningTimeout);\n      }\n      closed = true;\n      reject(error);\n\n      return streamable;\n    },\n    done(...args: [] | [React.ReactNode]) {\n      assertStream('.done()');\n\n      if (warningTimeout) {\n        clearTimeout(warningTimeout);\n      }\n      closed = true;\n      if (args.length) {\n        resolve({ value: args[0], done: true });\n        return streamable;\n      }\n      resolve({ value: currentValue, done: true });\n\n      return streamable;\n    },\n  };\n\n  return streamable;\n}\n\nexport { createStreamableUI };\n","import type OpenAI from 'openai';\nimport type { ReactNode } from 'react';\nimport { z } from 'zod';\nimport zodToJsonSchema from 'zod-to-json-schema';\nimport { OpenAIStream } from '../../streams';\nimport { consumeStream } from '../../util/consume-stream';\nimport { createResolvablePromise } from '../../util/create-resolvable-promise';\nimport { createStreamableUI } from '../streamable-ui/create-streamable-ui';\n\ntype Streamable = ReactNode | Promise<ReactNode>;\ntype Renderer<T> = (\n  props: T,\n) =>\n  | Streamable\n  | Generator<Streamable, Streamable, void>\n  | AsyncGenerator<Streamable, Streamable, void>;\n\n/**\n * `render` is a helper function to create a streamable UI from some LLMs.\n * This API only supports OpenAI's GPT models with Function Calling and Assistants Tools,\n * please use `streamUI` for compatibility with other providers.\n *\n * @deprecated It's recommended to use the `streamUI` API for compatibility with AI SDK Core APIs\n * and future features. This API will be removed in a future release.\n */\nexport function render<\n  TS extends {\n    [name: string]: z.Schema;\n  } = {},\n  FS extends {\n    [name: string]: z.Schema;\n  } = {},\n>(options: {\n  /**\n   * The model name to use. Must be OpenAI SDK compatible. Tools and Functions are only supported\n   * GPT models (3.5/4), OpenAI Assistants, Mistral small and large, and Fireworks firefunction-v1.\n   *\n   * @example \"gpt-3.5-turbo\"\n   */\n  model: string;\n  /**\n   * The provider instance to use. Currently the only provider available is OpenAI.\n   * This needs to match the model name.\n   */\n  provider: OpenAI;\n  messages: Parameters<\n    typeof OpenAI.prototype.chat.completions.create\n  >[0]['messages'];\n  text?: Renderer<{\n    /**\n     * The full text content from the model so far.\n     */\n    content: string;\n    /**\n     * The new appended text content from the model since the last `text` call.\n     */\n    delta: string;\n    /**\n     * Whether the model is done generating text.\n     * If `true`, the `content` will be the final output and this call will be the last.\n     */\n    done: boolean;\n  }>;\n  tools?: {\n    [name in keyof TS]: {\n      description?: string;\n      parameters: TS[name];\n      render: Renderer<z.infer<TS[name]>>;\n    };\n  };\n  functions?: {\n    [name in keyof FS]: {\n      description?: string;\n      parameters: FS[name];\n      render: Renderer<z.infer<FS[name]>>;\n    };\n  };\n  initial?: ReactNode;\n  temperature?: number;\n}): ReactNode {\n  const ui = createStreamableUI(options.initial);\n\n  // The default text renderer just returns the content as string.\n  const text = options.text\n    ? options.text\n    : ({ content }: { content: string }) => content;\n\n  const functions = options.functions\n    ? Object.entries(options.functions).map(\n        ([name, { description, parameters }]) => {\n          return {\n            name,\n            description,\n            parameters: zodToJsonSchema(parameters) as Record<string, unknown>,\n          };\n        },\n      )\n    : undefined;\n\n  const tools = options.tools\n    ? Object.entries(options.tools).map(\n        ([name, { description, parameters }]) => {\n          return {\n            type: 'function' as const,\n            function: {\n              name,\n              description,\n              parameters: zodToJsonSchema(parameters) as Record<\n                string,\n                unknown\n              >,\n            },\n          };\n        },\n      )\n    : undefined;\n\n  if (functions && tools) {\n    throw new Error(\n      \"You can't have both functions and tools defined. Please choose one or the other.\",\n    );\n  }\n\n  let finished: Promise<void> | undefined;\n\n  async function handleRender(\n    args: any,\n    renderer: undefined | Renderer<any>,\n    res: ReturnType<typeof createStreamableUI>,\n  ) {\n    if (!renderer) return;\n\n    const resolvable = createResolvablePromise<void>();\n\n    if (finished) {\n      finished = finished.then(() => resolvable.promise);\n    } else {\n      finished = resolvable.promise;\n    }\n\n    const value = renderer(args);\n    if (\n      value instanceof Promise ||\n      (value &&\n        typeof value === 'object' &&\n        'then' in value &&\n        typeof value.then === 'function')\n    ) {\n      const node = await (value as Promise<React.ReactNode>);\n      res.update(node);\n      resolvable.resolve(void 0);\n    } else if (\n      value &&\n      typeof value === 'object' &&\n      Symbol.asyncIterator in value\n    ) {\n      const it = value as AsyncGenerator<\n        React.ReactNode,\n        React.ReactNode,\n        void\n      >;\n      while (true) {\n        const { done, value } = await it.next();\n        res.update(value);\n        if (done) break;\n      }\n      resolvable.resolve(void 0);\n    } else if (value && typeof value === 'object' && Symbol.iterator in value) {\n      const it = value as Generator<React.ReactNode, React.ReactNode, void>;\n      while (true) {\n        const { done, value } = it.next();\n        res.update(value);\n        if (done) break;\n      }\n      resolvable.resolve(void 0);\n    } else {\n      res.update(value);\n      resolvable.resolve(void 0);\n    }\n  }\n\n  (async () => {\n    let hasFunction = false;\n    let content = '';\n\n    consumeStream(\n      OpenAIStream(\n        (await options.provider.chat.completions.create({\n          model: options.model,\n          messages: options.messages,\n          temperature: options.temperature,\n          stream: true,\n          ...(functions\n            ? {\n                functions,\n              }\n            : {}),\n          ...(tools\n            ? {\n                tools,\n              }\n            : {}),\n        })) as any,\n        {\n          ...(functions\n            ? {\n                async experimental_onFunctionCall(functionCallPayload) {\n                  hasFunction = true;\n                  handleRender(\n                    functionCallPayload.arguments,\n                    options.functions?.[functionCallPayload.name as any]\n                      ?.render,\n                    ui,\n                  );\n                },\n              }\n            : {}),\n          ...(tools\n            ? {\n                async experimental_onToolCall(toolCallPayload: any) {\n                  hasFunction = true;\n\n                  // TODO: We might need Promise.all here?\n                  for (const tool of toolCallPayload.tools) {\n                    handleRender(\n                      tool.func.arguments,\n                      options.tools?.[tool.func.name as any]?.render,\n                      ui,\n                    );\n                  }\n                },\n              }\n            : {}),\n          onText(chunk) {\n            content += chunk;\n            handleRender({ content, done: false, delta: chunk }, text, ui);\n          },\n          async onFinal() {\n            if (hasFunction) {\n              await finished;\n              ui.done();\n              return;\n            }\n\n            handleRender({ content, done: true }, text, ui);\n            await finished;\n            ui.done();\n          },\n        },\n      ),\n    );\n  })();\n\n  return ui.value;\n}\n","import {\n  createParser,\n  type EventSourceParser,\n  type ParsedEvent,\n  type ReconnectInterval,\n} from 'eventsource-parser';\nimport { OpenAIStreamCallbacks } from './openai-stream';\n\nexport interface FunctionCallPayload {\n  name: string;\n  arguments: Record<string, unknown>;\n}\nexport interface ToolCallPayload {\n  tools: {\n    id: string;\n    type: 'function';\n    func: {\n      name: string;\n      arguments: Record<string, unknown>;\n    };\n  }[];\n}\n\n/**\n * Configuration options and helper callback methods for AIStream stream lifecycle events.\n * @interface\n */\nexport interface AIStreamCallbacksAndOptions {\n  /** `onStart`: Called once when the stream is initialized. */\n  onStart?: () => Promise<void> | void;\n  /** `onCompletion`: Called for each tokenized message. */\n  onCompletion?: (completion: string) => Promise<void> | void;\n  /** `onFinal`: Called once when the stream is closed with the final completion message. */\n  onFinal?: (completion: string) => Promise<void> | void;\n  /** `onToken`: Called for each tokenized message. */\n  onToken?: (token: string) => Promise<void> | void;\n  /** `onText`: Called for each text chunk. */\n  onText?: (text: string) => Promise<void> | void;\n  /**\n   * @deprecated This flag is no longer used and only retained for backwards compatibility.\n   * You can remove it from your code.\n   */\n  experimental_streamData?: boolean;\n}\n\n/**\n * Options for the AIStreamParser.\n * @interface\n * @property {string} event - The event (type) from the server side event stream.\n */\nexport interface AIStreamParserOptions {\n  event?: string;\n}\n\n/**\n * Custom parser for AIStream data.\n * @interface\n * @param {string} data - The data to be parsed.\n * @param {AIStreamParserOptions} options - The options for the parser.\n * @returns {string | void} The parsed data or void.\n */\nexport interface AIStreamParser {\n  (data: string, options: AIStreamParserOptions):\n    | string\n    | void\n    | { isText: false; content: string };\n}\n\n/**\n * Creates a TransformStream that parses events from an EventSource stream using a custom parser.\n * @param {AIStreamParser} customParser - Function to handle event data.\n * @returns {TransformStream<Uint8Array, string>} TransformStream parsing events.\n */\nexport function createEventStreamTransformer(\n  customParser?: AIStreamParser,\n): TransformStream<Uint8Array, string | { isText: false; content: string }> {\n  const textDecoder = new TextDecoder();\n  let eventSourceParser: EventSourceParser;\n\n  return new TransformStream({\n    async start(controller): Promise<void> {\n      eventSourceParser = createParser(\n        (event: ParsedEvent | ReconnectInterval) => {\n          if (\n            ('data' in event &&\n              event.type === 'event' &&\n              event.data === '[DONE]') ||\n            // Replicate doesn't send [DONE] but does send a 'done' event\n            // @see https://replicate.com/docs/streaming\n            (event as any).event === 'done'\n          ) {\n            controller.terminate();\n            return;\n          }\n\n          if ('data' in event) {\n            const parsedMessage = customParser\n              ? customParser(event.data, {\n                  event: event.event,\n                })\n              : event.data;\n            if (parsedMessage) controller.enqueue(parsedMessage);\n          }\n        },\n      );\n    },\n\n    transform(chunk) {\n      eventSourceParser.feed(textDecoder.decode(chunk));\n    },\n  });\n}\n\n/**\n * Creates a transform stream that encodes input messages and invokes optional callback functions.\n * The transform stream uses the provided callbacks to execute custom logic at different stages of the stream's lifecycle.\n * - `onStart`: Called once when the stream is initialized.\n * - `onToken`: Called for each tokenized message.\n * - `onCompletion`: Called every time an AIStream completion message is received. This can occur multiple times when using e.g. OpenAI functions\n * - `onFinal`: Called once when the stream is closed with the final completion message.\n *\n * This function is useful when you want to process a stream of messages and perform specific actions during the stream's lifecycle.\n *\n * @param {AIStreamCallbacksAndOptions} [callbacks] - An object containing the callback functions.\n * @return {TransformStream<string, Uint8Array>} A transform stream that encodes input messages as Uint8Array and allows the execution of custom logic through callbacks.\n *\n * @example\n * const callbacks = {\n *   onStart: async () => console.log('Stream started'),\n *   onToken: async (token) => console.log(`Token: ${token}`),\n *   onCompletion: async (completion) => console.log(`Completion: ${completion}`)\n *   onFinal: async () => data.close()\n * };\n * const transformer = createCallbacksTransformer(callbacks);\n */\nexport function createCallbacksTransformer(\n  cb: AIStreamCallbacksAndOptions | OpenAIStreamCallbacks | undefined,\n): TransformStream<string | { isText: false; content: string }, Uint8Array> {\n  const textEncoder = new TextEncoder();\n  let aggregatedResponse = '';\n  const callbacks = cb || {};\n\n  return new TransformStream({\n    async start(): Promise<void> {\n      if (callbacks.onStart) await callbacks.onStart();\n    },\n\n    async transform(message, controller): Promise<void> {\n      const content = typeof message === 'string' ? message : message.content;\n\n      controller.enqueue(textEncoder.encode(content));\n\n      aggregatedResponse += content;\n\n      if (callbacks.onToken) await callbacks.onToken(content);\n      if (callbacks.onText && typeof message === 'string') {\n        await callbacks.onText(message);\n      }\n    },\n\n    async flush(): Promise<void> {\n      const isOpenAICallbacks = isOfTypeOpenAIStreamCallbacks(callbacks);\n      // If it's OpenAICallbacks, it has an experimental_onFunctionCall which means that the createFunctionCallTransformer\n      // will handle calling onComplete.\n      if (callbacks.onCompletion) {\n        await callbacks.onCompletion(aggregatedResponse);\n      }\n\n      if (callbacks.onFinal && !isOpenAICallbacks) {\n        await callbacks.onFinal(aggregatedResponse);\n      }\n    },\n  });\n}\n\nfunction isOfTypeOpenAIStreamCallbacks(\n  callbacks: AIStreamCallbacksAndOptions | OpenAIStreamCallbacks,\n): callbacks is OpenAIStreamCallbacks {\n  return 'experimental_onFunctionCall' in callbacks;\n}\n/**\n * Returns a stateful function that, when invoked, trims leading whitespace\n * from the input text. The trimming only occurs on the first invocation, ensuring that\n * subsequent calls do not alter the input text. This is particularly useful in scenarios\n * where a text stream is being processed and only the initial whitespace should be removed.\n *\n * @return {function(string): string} A function that takes a string as input and returns a string\n * with leading whitespace removed if it is the first invocation; otherwise, it returns the input unchanged.\n *\n * @example\n * const trimStart = trimStartOfStreamHelper();\n * const output1 = trimStart(\"   text\"); // \"text\"\n * const output2 = trimStart(\"   text\"); // \"   text\"\n *\n */\nexport function trimStartOfStreamHelper(): (text: string) => string {\n  let isStreamStart = true;\n\n  return (text: string): string => {\n    if (isStreamStart) {\n      text = text.trimStart();\n      if (text) isStreamStart = false;\n    }\n    return text;\n  };\n}\n\n/**\n * Returns a ReadableStream created from the response, parsed and handled with custom logic.\n * The stream goes through two transformation stages, first parsing the events and then\n * invoking the provided callbacks.\n *\n * For 2xx HTTP responses:\n * - The function continues with standard stream processing.\n *\n * For non-2xx HTTP responses:\n * - If the response body is defined, it asynchronously extracts and decodes the response body.\n * - It then creates a custom ReadableStream to propagate a detailed error message.\n *\n * @param {Response} response - The response.\n * @param {AIStreamParser} customParser - The custom parser function.\n * @param {AIStreamCallbacksAndOptions} callbacks - The callbacks.\n * @return {ReadableStream} The AIStream.\n * @throws Will throw an error if the response is not OK.\n */\nexport function AIStream(\n  response: Response,\n  customParser?: AIStreamParser,\n  callbacks?: AIStreamCallbacksAndOptions,\n): ReadableStream<Uint8Array> {\n  if (!response.ok) {\n    if (response.body) {\n      const reader = response.body.getReader();\n      return new ReadableStream({\n        async start(controller) {\n          const { done, value } = await reader.read();\n          if (!done) {\n            const errorText = new TextDecoder().decode(value);\n            controller.error(new Error(`Response error: ${errorText}`));\n          }\n        },\n      });\n    } else {\n      return new ReadableStream({\n        start(controller) {\n          controller.error(new Error('Response error: No response body'));\n        },\n      });\n    }\n  }\n\n  const responseBodyStream = response.body || createEmptyReadableStream();\n\n  return responseBodyStream\n    .pipeThrough(createEventStreamTransformer(customParser))\n    .pipeThrough(createCallbacksTransformer(callbacks));\n}\n\n// outputs lines like\n// 0: chunk\n// 0: more chunk\n// 1: a fct call\n// z: added data from Data\n\n/**\n * Creates an empty ReadableStream that immediately closes upon creation.\n * This function is used as a fallback for creating a ReadableStream when the response body is null or undefined,\n * ensuring that the subsequent pipeline processing doesn't fail due to a lack of a stream.\n *\n * @returns {ReadableStream} An empty and closed ReadableStream instance.\n */\nfunction createEmptyReadableStream(): ReadableStream {\n  return new ReadableStream({\n    start(controller) {\n      controller.close();\n    },\n  });\n}\n\n/**\n * Implements ReadableStream.from(asyncIterable), which isn't documented in MDN and isn't implemented in node.\n * https://github.com/whatwg/streams/commit/8d7a0bf26eb2cc23e884ddbaac7c1da4b91cf2bc\n */\nexport function readableFromAsyncIterable<T>(iterable: AsyncIterable<T>) {\n  let it = iterable[Symbol.asyncIterator]();\n  return new ReadableStream<T>({\n    async pull(controller) {\n      const { done, value } = await it.next();\n      if (done) controller.close();\n      else controller.enqueue(value);\n    },\n\n    async cancel(reason) {\n      await it.return?.(reason);\n    },\n  });\n}\n","import { JSONValue, formatStreamPart } from '@ai-sdk/ui-utils';\nimport { HANGING_STREAM_WARNING_TIME_MS } from '../util/constants';\n\n/**\n * A stream wrapper to send custom JSON-encoded data back to the client.\n */\nexport class StreamData {\n  private encoder = new TextEncoder();\n\n  private controller: ReadableStreamController<Uint8Array> | null = null;\n  public stream: ReadableStream<Uint8Array>;\n\n  private isClosed: boolean = false;\n  private warningTimeout: NodeJS.Timeout | null = null;\n\n  constructor() {\n    const self = this;\n\n    this.stream = new ReadableStream({\n      start: async controller => {\n        self.controller = controller;\n\n        // Set a timeout to show a warning if the stream is not closed within 3 seconds\n        if (process.env.NODE_ENV === 'development') {\n          self.warningTimeout = setTimeout(() => {\n            console.warn(\n              'The data stream is hanging. Did you forget to close it with `data.close()`?',\n            );\n          }, HANGING_STREAM_WARNING_TIME_MS);\n        }\n      },\n      pull: controller => {\n        // No-op: we don't need to do anything special on pull\n      },\n      cancel: reason => {\n        this.isClosed = true;\n      },\n    });\n  }\n\n  async close(): Promise<void> {\n    if (this.isClosed) {\n      throw new Error('Data Stream has already been closed.');\n    }\n\n    if (!this.controller) {\n      throw new Error('Stream controller is not initialized.');\n    }\n\n    this.controller.close();\n    this.isClosed = true;\n\n    // Clear the warning timeout if the stream is closed\n    if (this.warningTimeout) {\n      clearTimeout(this.warningTimeout);\n    }\n  }\n\n  append(value: JSONValue): void {\n    if (this.isClosed) {\n      throw new Error('Data Stream has already been closed.');\n    }\n\n    if (!this.controller) {\n      throw new Error('Stream controller is not initialized.');\n    }\n\n    this.controller.enqueue(\n      this.encoder.encode(formatStreamPart('data', [value])),\n    );\n  }\n\n  appendMessageAnnotation(value: JSONValue): void {\n    if (this.isClosed) {\n      throw new Error('Data Stream has already been closed.');\n    }\n\n    if (!this.controller) {\n      throw new Error('Stream controller is not initialized.');\n    }\n\n    this.controller.enqueue(\n      this.encoder.encode(formatStreamPart('message_annotations', [value])),\n    );\n  }\n}\n\n/**\n * A TransformStream for LLMs that do not have their own transform stream handlers managing encoding (e.g. OpenAIStream has one for function call handling).\n * This assumes every chunk is a 'text' chunk.\n */\nexport function createStreamDataTransformer() {\n  const encoder = new TextEncoder();\n  const decoder = new TextDecoder();\n  return new TransformStream({\n    transform: async (chunk, controller) => {\n      const message = decoder.decode(chunk);\n      controller.enqueue(encoder.encode(formatStreamPart('text', message)));\n    },\n  });\n}\n\n/**\n@deprecated Use `StreamData` instead.\n */\nexport class experimental_StreamData extends StreamData {}\n","import {\n  CreateMessage,\n  FunctionCall,\n  JSONValue,\n  ToolCall,\n  createChunkDecoder,\n  formatStreamPart,\n} from '@ai-sdk/ui-utils';\nimport {\n  AIStream,\n  FunctionCallPayload,\n  ToolCallPayload,\n  createCallbacksTransformer,\n  readableFromAsyncIterable,\n  trimStartOfStreamHelper,\n  type AIStreamCallbacksAndOptions,\n} from './ai-stream';\nimport { AzureChatCompletions } from './azure-openai-types';\nimport { createStreamDataTransformer } from './stream-data';\n\nexport type OpenAIStreamCallbacks = AIStreamCallbacksAndOptions & {\n  /**\n   * @example\n   * ```js\n   * const response = await openai.chat.completions.create({\n   *   model: 'gpt-3.5-turbo-0613',\n   *   stream: true,\n   *   messages,\n   *   functions,\n   * })\n   *\n   * const stream = OpenAIStream(response, {\n   *   experimental_onFunctionCall: async (functionCallPayload, createFunctionCallMessages) => {\n   *     // ... run your custom logic here\n   *     const result = await myFunction(functionCallPayload)\n   *\n   *     // Ask for another completion, or return a string to send to the client as an assistant message.\n   *     return await openai.chat.completions.create({\n   *       model: 'gpt-3.5-turbo-0613',\n   *       stream: true,\n   *       // Append the relevant \"assistant\" and \"function\" call messages\n   *       messages: [...messages, ...createFunctionCallMessages(result)],\n   *       functions,\n   *     })\n   *   }\n   * })\n   * ```\n   */\n  experimental_onFunctionCall?: (\n    functionCallPayload: FunctionCallPayload,\n    createFunctionCallMessages: (\n      functionCallResult: JSONValue,\n    ) => CreateMessage[],\n  ) => Promise<\n    Response | undefined | void | string | AsyncIterableOpenAIStreamReturnTypes\n  >;\n  /**\n   * @example\n   * ```js\n   * const response = await openai.chat.completions.create({\n   *   model: 'gpt-3.5-turbo-1106', // or gpt-4-1106-preview\n   *   stream: true,\n   *   messages,\n   *   tools,\n   *   tool_choice: \"auto\", // auto is default, but we'll be explicit\n   * })\n   *\n   * const stream = OpenAIStream(response, {\n   *   experimental_onToolCall: async (toolCallPayload, appendToolCallMessages) => {\n   *    let messages: CreateMessage[] = []\n   *    //   There might be multiple tool calls, so we need to iterate through them\n   *    for (const tool of toolCallPayload.tools) {\n   *     // ... run your custom logic here\n   *     const result = await myFunction(tool.function)\n   *    // Append the relevant \"assistant\" and \"tool\" call messages\n   *     appendToolCallMessage({tool_call_id:tool.id, function_name:tool.function.name, tool_call_result:result})\n   *    }\n   *     // Ask for another completion, or return a string to send to the client as an assistant message.\n   *     return await openai.chat.completions.create({\n   *       model: 'gpt-3.5-turbo-1106', // or gpt-4-1106-preview\n   *       stream: true,\n   *       // Append the results messages, calling appendToolCallMessage without\n   *       // any arguments will jsut return the accumulated messages\n   *       messages: [...messages, ...appendToolCallMessage()],\n   *       tools,\n   *        tool_choice: \"auto\", // auto is default, but we'll be explicit\n   *     })\n   *   }\n   * })\n   * ```\n   */\n  experimental_onToolCall?: (\n    toolCallPayload: ToolCallPayload,\n    appendToolCallMessage: (result?: {\n      tool_call_id: string;\n      function_name: string;\n      tool_call_result: JSONValue;\n    }) => CreateMessage[],\n  ) => Promise<\n    Response | undefined | void | string | AsyncIterableOpenAIStreamReturnTypes\n  >;\n};\n\n// https://github.com/openai/openai-node/blob/07b3504e1c40fd929f4aae1651b83afc19e3baf8/src/resources/chat/completions.ts#L28-L40\ninterface ChatCompletionChunk {\n  id: string;\n  choices: Array<ChatCompletionChunkChoice>;\n  created: number;\n  model: string;\n  object: string;\n}\n\n// https://github.com/openai/openai-node/blob/07b3504e1c40fd929f4aae1651b83afc19e3baf8/src/resources/chat/completions.ts#L43-L49\n// Updated for https://github.com/openai/openai-node/commit/f10c757d831d90407ba47b4659d9cd34b1a35b1d\n// Updated to https://github.com/openai/openai-node/commit/84b43280089eacdf18f171723591856811beddce\ninterface ChatCompletionChunkChoice {\n  delta: ChoiceDelta;\n  finish_reason:\n    | 'stop'\n    | 'length'\n    | 'tool_calls'\n    | 'content_filter'\n    | 'function_call'\n    | null;\n  index: number;\n}\n\n// https://github.com/openai/openai-node/blob/07b3504e1c40fd929f4aae1651b83afc19e3baf8/src/resources/chat/completions.ts#L123-L139\n// Updated to https://github.com/openai/openai-node/commit/84b43280089eacdf18f171723591856811beddce\ninterface ChoiceDelta {\n  /**\n   * The contents of the chunk message.\n   */\n  content?: string | null;\n\n  /**\n   * The name and arguments of a function that should be called, as generated by the\n   * model.\n   */\n  function_call?: FunctionCall;\n\n  /**\n   * The role of the author of this message.\n   */\n  role?: 'system' | 'user' | 'assistant' | 'tool';\n\n  tool_calls?: Array<DeltaToolCall>;\n}\n\n// From https://github.com/openai/openai-node/blob/master/src/resources/chat/completions.ts\n// Updated to https://github.com/openai/openai-node/commit/84b43280089eacdf18f171723591856811beddce\ninterface DeltaToolCall {\n  index: number;\n\n  /**\n   * The ID of the tool call.\n   */\n  id?: string;\n\n  /**\n   * The function that the model called.\n   */\n  function?: ToolCallFunction;\n\n  /**\n   * The type of the tool. Currently, only `function` is supported.\n   */\n  type?: 'function';\n}\n\n// From https://github.com/openai/openai-node/blob/master/src/resources/chat/completions.ts\n// Updated to https://github.com/openai/openai-node/commit/84b43280089eacdf18f171723591856811beddce\ninterface ToolCallFunction {\n  /**\n   * The arguments to call the function with, as generated by the model in JSON\n   * format. Note that the model does not always generate valid JSON, and may\n   * hallucinate parameters not defined by your function schema. Validate the\n   * arguments in your code before calling your function.\n   */\n  arguments?: string;\n\n  /**\n   * The name of the function to call.\n   */\n  name?: string;\n}\n\n/**\n * https://github.com/openai/openai-node/blob/3ec43ee790a2eb6a0ccdd5f25faa23251b0f9b8e/src/resources/completions.ts#L28C1-L64C1\n * Completions API. Streamed and non-streamed responses are the same.\n */\ninterface Completion {\n  /**\n   * A unique identifier for the completion.\n   */\n  id: string;\n\n  /**\n   * The list of completion choices the model generated for the input prompt.\n   */\n  choices: Array<CompletionChoice>;\n\n  /**\n   * The Unix timestamp of when the completion was created.\n   */\n  created: number;\n\n  /**\n   * The model used for completion.\n   */\n  model: string;\n\n  /**\n   * The object type, which is always \"text_completion\"\n   */\n  object: string;\n\n  /**\n   * Usage statistics for the completion request.\n   */\n  usage?: CompletionUsage;\n}\n\ninterface CompletionChoice {\n  /**\n   * The reason the model stopped generating tokens. This will be `stop` if the model\n   * hit a natural stop point or a provided stop sequence, or `length` if the maximum\n   * number of tokens specified in the request was reached.\n   */\n  finish_reason: 'stop' | 'length' | 'content_filter';\n\n  index: number;\n\n  // edited: Removed CompletionChoice.logProbs and replaced with any\n  logprobs: any | null;\n\n  text: string;\n}\n\nexport interface CompletionUsage {\n  /**\n   * Usage statistics for the completion request.\n   */\n\n  /**\n   * Number of tokens in the generated completion.\n   */\n  completion_tokens: number;\n\n  /**\n   * Number of tokens in the prompt.\n   */\n  prompt_tokens: number;\n\n  /**\n   * Total number of tokens used in the request (prompt + completion).\n   */\n  total_tokens: number;\n}\n\n/**\n * Creates a parser function for processing the OpenAI stream data.\n * The parser extracts and trims text content from the JSON data. This parser\n * can handle data for chat or completion models.\n *\n * @return {(data: string) => string | void| { isText: false; content: string }}\n * A parser function that takes a JSON string as input and returns the extracted text content,\n * a complex object with isText: false for function/tool calls, or nothing.\n */\nfunction parseOpenAIStream(): (\n  data: string,\n) => string | void | { isText: false; content: string } {\n  const extract = chunkToText();\n  return data => extract(JSON.parse(data) as OpenAIStreamReturnTypes);\n}\n\n/**\n * Reads chunks from OpenAI's new Streamable interface, which is essentially\n * the same as the old Response body interface with an included SSE parser\n * doing the parsing for us.\n */\nasync function* streamable(stream: AsyncIterableOpenAIStreamReturnTypes) {\n  const extract = chunkToText();\n\n  for await (let chunk of stream) {\n    // convert chunk if it is an Azure chat completion. Azure does not expose all\n    // properties in the interfaces, and also uses camelCase instead of snake_case\n    if ('promptFilterResults' in chunk) {\n      chunk = {\n        id: chunk.id,\n        created: chunk.created.getDate(),\n        object: (chunk as any).object, // not exposed by Azure API\n        model: (chunk as any).model, // not exposed by Azure API\n        choices: chunk.choices.map(choice => ({\n          delta: {\n            content: choice.delta?.content,\n            function_call: choice.delta?.functionCall,\n            role: choice.delta?.role as any,\n            tool_calls: choice.delta?.toolCalls?.length\n              ? choice.delta?.toolCalls?.map((toolCall, index) => ({\n                  index,\n                  id: toolCall.id,\n                  function: toolCall.function,\n                  type: toolCall.type,\n                }))\n              : undefined,\n          },\n          finish_reason: choice.finishReason as any,\n          index: choice.index,\n        })),\n      } satisfies ChatCompletionChunk;\n    }\n\n    const text = extract(chunk);\n\n    if (text) yield text;\n  }\n}\n\nfunction chunkToText(): (\n  chunk: OpenAIStreamReturnTypes,\n) => string | { isText: false; content: string } | void {\n  const trimStartOfStream = trimStartOfStreamHelper();\n  let isFunctionStreamingIn: boolean;\n  return json => {\n    if (isChatCompletionChunk(json)) {\n      const delta = json.choices[0]?.delta;\n      if (delta.function_call?.name) {\n        isFunctionStreamingIn = true;\n        return {\n          isText: false,\n          content: `{\"function_call\": {\"name\": \"${delta.function_call.name}\", \"arguments\": \"`,\n        };\n      } else if (delta.tool_calls?.[0]?.function?.name) {\n        isFunctionStreamingIn = true;\n        const toolCall = delta.tool_calls[0];\n        if (toolCall.index === 0) {\n          return {\n            isText: false,\n            content: `{\"tool_calls\":[ {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${toolCall.function?.name}\", \"arguments\": \"`,\n          };\n        } else {\n          return {\n            isText: false,\n            content: `\"}}, {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${toolCall.function?.name}\", \"arguments\": \"`,\n          };\n        }\n      } else if (delta.function_call?.arguments) {\n        return {\n          isText: false,\n          content: cleanupArguments(delta.function_call?.arguments),\n        };\n      } else if (delta.tool_calls?.[0]?.function?.arguments) {\n        return {\n          isText: false,\n          content: cleanupArguments(delta.tool_calls?.[0]?.function?.arguments),\n        };\n      } else if (\n        isFunctionStreamingIn &&\n        (json.choices[0]?.finish_reason === 'function_call' ||\n          json.choices[0]?.finish_reason === 'stop')\n      ) {\n        isFunctionStreamingIn = false; // Reset the flag\n        return {\n          isText: false,\n          content: '\"}}',\n        };\n      } else if (\n        isFunctionStreamingIn &&\n        json.choices[0]?.finish_reason === 'tool_calls'\n      ) {\n        isFunctionStreamingIn = false; // Reset the flag\n        return {\n          isText: false,\n          content: '\"}}]}',\n        };\n      }\n    }\n\n    const text = trimStartOfStream(\n      isChatCompletionChunk(json) && json.choices[0].delta.content\n        ? json.choices[0].delta.content\n        : isCompletion(json)\n        ? json.choices[0].text\n        : '',\n    );\n\n    return text;\n  };\n\n  function cleanupArguments(argumentChunk: string) {\n    let escapedPartialJson = argumentChunk\n      .replace(/\\\\/g, '\\\\\\\\') // Replace backslashes first to prevent double escaping\n      .replace(/\\//g, '\\\\/') // Escape slashes\n      .replace(/\"/g, '\\\\\"') // Escape double quotes\n      .replace(/\\n/g, '\\\\n') // Escape new lines\n      .replace(/\\r/g, '\\\\r') // Escape carriage returns\n      .replace(/\\t/g, '\\\\t') // Escape tabs\n      .replace(/\\f/g, '\\\\f'); // Escape form feeds\n\n    return `${escapedPartialJson}`;\n  }\n}\n\nconst __internal__OpenAIFnMessagesSymbol = Symbol(\n  'internal_openai_fn_messages',\n);\n\ntype AsyncIterableOpenAIStreamReturnTypes =\n  | AsyncIterable<ChatCompletionChunk>\n  | AsyncIterable<Completion>\n  | AsyncIterable<AzureChatCompletions>;\n\ntype ExtractType<T> = T extends AsyncIterable<infer U> ? U : never;\n\ntype OpenAIStreamReturnTypes =\n  ExtractType<AsyncIterableOpenAIStreamReturnTypes>;\n\nfunction isChatCompletionChunk(\n  data: OpenAIStreamReturnTypes,\n): data is ChatCompletionChunk {\n  return (\n    'choices' in data &&\n    data.choices &&\n    data.choices[0] &&\n    'delta' in data.choices[0]\n  );\n}\n\nfunction isCompletion(data: OpenAIStreamReturnTypes): data is Completion {\n  return (\n    'choices' in data &&\n    data.choices &&\n    data.choices[0] &&\n    'text' in data.choices[0]\n  );\n}\n\n/**\n * @deprecated Use the [OpenAI provider](https://sdk.vercel.ai/providers/ai-sdk-providers/openai) instead.\n */\nexport function OpenAIStream(\n  res: Response | AsyncIterableOpenAIStreamReturnTypes,\n  callbacks?: OpenAIStreamCallbacks,\n): ReadableStream {\n  // Annotate the internal `messages` property for recursive function calls\n  const cb:\n    | undefined\n    | (OpenAIStreamCallbacks & {\n        [__internal__OpenAIFnMessagesSymbol]?: CreateMessage[];\n      }) = callbacks;\n\n  let stream: ReadableStream<Uint8Array>;\n  if (Symbol.asyncIterator in res) {\n    stream = readableFromAsyncIterable(streamable(res)).pipeThrough(\n      createCallbacksTransformer(\n        cb?.experimental_onFunctionCall || cb?.experimental_onToolCall\n          ? {\n              ...cb,\n              onFinal: undefined,\n            }\n          : {\n              ...cb,\n            },\n      ),\n    );\n  } else {\n    stream = AIStream(\n      res,\n      parseOpenAIStream(),\n      cb?.experimental_onFunctionCall || cb?.experimental_onToolCall\n        ? {\n            ...cb,\n            onFinal: undefined,\n          }\n        : {\n            ...cb,\n          },\n    );\n  }\n\n  if (cb && (cb.experimental_onFunctionCall || cb.experimental_onToolCall)) {\n    const functionCallTransformer = createFunctionCallTransformer(cb);\n    return stream.pipeThrough(functionCallTransformer);\n  } else {\n    return stream.pipeThrough(createStreamDataTransformer());\n  }\n}\n\nfunction createFunctionCallTransformer(\n  callbacks: OpenAIStreamCallbacks & {\n    [__internal__OpenAIFnMessagesSymbol]?: CreateMessage[];\n  },\n): TransformStream<Uint8Array, Uint8Array> {\n  const textEncoder = new TextEncoder();\n  let isFirstChunk = true;\n  let aggregatedResponse = '';\n  let aggregatedFinalCompletionResponse = '';\n  let isFunctionStreamingIn = false;\n\n  let functionCallMessages: CreateMessage[] =\n    callbacks[__internal__OpenAIFnMessagesSymbol] || [];\n\n  const decode = createChunkDecoder();\n\n  return new TransformStream({\n    async transform(chunk, controller): Promise<void> {\n      const message = decode(chunk);\n      aggregatedFinalCompletionResponse += message;\n\n      const shouldHandleAsFunction =\n        isFirstChunk &&\n        (message.startsWith('{\"function_call\":') ||\n          message.startsWith('{\"tool_calls\":'));\n\n      if (shouldHandleAsFunction) {\n        isFunctionStreamingIn = true;\n        aggregatedResponse += message;\n        isFirstChunk = false;\n        return;\n      }\n\n      // Stream as normal\n      if (!isFunctionStreamingIn) {\n        controller.enqueue(\n          textEncoder.encode(formatStreamPart('text', message)),\n        );\n        return;\n      } else {\n        aggregatedResponse += message;\n      }\n    },\n    async flush(controller): Promise<void> {\n      try {\n        if (\n          !isFirstChunk &&\n          isFunctionStreamingIn &&\n          (callbacks.experimental_onFunctionCall ||\n            callbacks.experimental_onToolCall)\n        ) {\n          isFunctionStreamingIn = false;\n          const payload = JSON.parse(aggregatedResponse);\n          // Append the function call message to the list\n          let newFunctionCallMessages: CreateMessage[] = [\n            ...functionCallMessages,\n          ];\n\n          let functionResponse:\n            | Response\n            | undefined\n            | void\n            | string\n            | AsyncIterableOpenAIStreamReturnTypes\n            | undefined = undefined;\n          // This callbacks.experimental_onFunctionCall check should not be necessary but TS complains\n          if (callbacks.experimental_onFunctionCall) {\n            // If the user is using the experimental_onFunctionCall callback, they should not be using tools\n            // if payload.function_call is not defined by time we get here we must have gotten a tool response\n            // and the user had defined experimental_onToolCall\n            if (payload.function_call === undefined) {\n              console.warn(\n                'experimental_onFunctionCall should not be defined when using tools',\n              );\n            }\n\n            const argumentsPayload = JSON.parse(\n              payload.function_call.arguments,\n            );\n\n            functionResponse = await callbacks.experimental_onFunctionCall(\n              {\n                name: payload.function_call.name,\n                arguments: argumentsPayload,\n              },\n              result => {\n                // Append the function call request and result messages to the list\n                newFunctionCallMessages = [\n                  ...functionCallMessages,\n                  {\n                    role: 'assistant',\n                    content: '',\n                    function_call: payload.function_call,\n                  },\n                  {\n                    role: 'function',\n                    name: payload.function_call.name,\n                    content: JSON.stringify(result),\n                  },\n                ];\n                // Return it to the user\n                return newFunctionCallMessages;\n              },\n            );\n          }\n          if (callbacks.experimental_onToolCall) {\n            const toolCalls: ToolCallPayload = {\n              tools: [],\n            };\n            for (const tool of payload.tool_calls) {\n              toolCalls.tools.push({\n                id: tool.id,\n                type: 'function',\n                func: {\n                  name: tool.function.name,\n                  arguments: JSON.parse(tool.function.arguments),\n                },\n              });\n            }\n            let responseIndex = 0;\n            try {\n              functionResponse = await callbacks.experimental_onToolCall(\n                toolCalls,\n                result => {\n                  if (result) {\n                    const { tool_call_id, function_name, tool_call_result } =\n                      result;\n                    // Append the function call request and result messages to the list\n                    newFunctionCallMessages = [\n                      ...newFunctionCallMessages,\n                      // Only append the assistant message if it's the first response\n                      ...(responseIndex === 0\n                        ? [\n                            {\n                              role: 'assistant' as const,\n                              content: '',\n                              tool_calls: payload.tool_calls.map(\n                                (tc: ToolCall) => ({\n                                  id: tc.id,\n                                  type: 'function',\n                                  function: {\n                                    name: tc.function.name,\n                                    // we send the arguments an object to the user, but as the API expects a string, we need to stringify it\n                                    arguments: JSON.stringify(\n                                      tc.function.arguments,\n                                    ),\n                                  },\n                                }),\n                              ),\n                            },\n                          ]\n                        : []),\n                      // Append the function call result message\n                      {\n                        role: 'tool',\n                        tool_call_id,\n                        name: function_name,\n                        content: JSON.stringify(tool_call_result),\n                      },\n                    ];\n                    responseIndex++;\n                  }\n                  // Return it to the user\n                  return newFunctionCallMessages;\n                },\n              );\n            } catch (e) {\n              console.error('Error calling experimental_onToolCall:', e);\n            }\n          }\n\n          if (!functionResponse) {\n            // The user didn't do anything with the function call on the server and wants\n            // to either do nothing or run it on the client\n            // so we just return the function call as a message\n            controller.enqueue(\n              textEncoder.encode(\n                formatStreamPart(\n                  payload.function_call ? 'function_call' : 'tool_calls',\n                  // parse to prevent double-encoding:\n                  JSON.parse(aggregatedResponse),\n                ),\n              ),\n            );\n            return;\n          } else if (typeof functionResponse === 'string') {\n            // The user returned a string, so we just return it as a message\n            controller.enqueue(\n              textEncoder.encode(formatStreamPart('text', functionResponse)),\n            );\n            aggregatedFinalCompletionResponse = functionResponse;\n            return;\n          }\n\n          // Recursively:\n\n          // We don't want to trigger onStart or onComplete recursively\n          // so we remove them from the callbacks\n          // see https://github.com/vercel/ai/issues/351\n          const filteredCallbacks: OpenAIStreamCallbacks = {\n            ...callbacks,\n            onStart: undefined,\n          };\n          // We only want onFinal to be called the _last_ time\n          callbacks.onFinal = undefined;\n\n          const openAIStream = OpenAIStream(functionResponse, {\n            ...filteredCallbacks,\n            [__internal__OpenAIFnMessagesSymbol]: newFunctionCallMessages,\n          } as AIStreamCallbacksAndOptions);\n\n          const reader = openAIStream.getReader();\n\n          while (true) {\n            const { done, value } = await reader.read();\n            if (done) {\n              break;\n            }\n            controller.enqueue(value);\n          }\n        }\n      } finally {\n        if (callbacks.onFinal && aggregatedFinalCompletionResponse) {\n          await callbacks.onFinal(aggregatedFinalCompletionResponse);\n        }\n      }\n    },\n  });\n}\n","/**\n * Consumes a ReadableStream until it's fully read.\n *\n * This function reads the stream chunk by chunk until the stream is exhausted.\n * It doesn't process or return the data from the stream; it simply ensures\n * that the entire stream is read.\n *\n * @param {ReadableStream} stream - The ReadableStream to be consumed.\n * @returns {Promise<void>} A promise that resolves when the stream is fully consumed.\n */\nexport async function consumeStream(stream: ReadableStream): Promise<void> {\n  const reader = stream.getReader();\n  while (true) {\n    const { done } = await reader.read();\n    if (done) break;\n  }\n}\n","export const STREAMABLE_VALUE_TYPE = Symbol.for('ui.streamable.value');\n\nexport type StreamablePatch = undefined | [0, string]; // Append string.\n\ndeclare const __internal_curr: unique symbol;\ndeclare const __internal_error: unique symbol;\n\n/**\n * StreamableValue is a value that can be streamed over the network via AI Actions.\n * To read the streamed values, use the `readStreamableValue` or `useStreamableValue` APIs.\n */\nexport type StreamableValue<T = any, E = any> = {\n  /**\n   * @internal Use `readStreamableValue` to read the values.\n   */\n  type?: typeof STREAMABLE_VALUE_TYPE;\n  /**\n   * @internal Use `readStreamableValue` to read the values.\n   */\n  curr?: T;\n  /**\n   * @internal Use `readStreamableValue` to read the values.\n   */\n  error?: E;\n  /**\n   * @internal Use `readStreamableValue` to read the values.\n   */\n  diff?: StreamablePatch;\n  /**\n   * @internal Use `readStreamableValue` to read the values.\n   */\n  next?: Promise<StreamableValue<T, E>>;\n\n  // branded types to maintain type signature after internal properties are stripped.\n  [__internal_curr]?: T;\n  [__internal_error]?: E;\n};\n","import { HANGING_STREAM_WARNING_TIME_MS } from '../../util/constants';\nimport { createResolvablePromise } from '../../util/create-resolvable-promise';\nimport {\n  STREAMABLE_VALUE_TYPE,\n  StreamablePatch,\n  StreamableValue,\n} from './streamable-value';\n\nconst STREAMABLE_VALUE_INTERNAL_LOCK = Symbol('streamable.value.lock');\n\n/**\n * Create a wrapped, changeable value that can be streamed to the client.\n * On the client side, the value can be accessed via the readStreamableValue() API.\n */\nfunction createStreamableValue<T = any, E = any>(\n  initialValue?: T | ReadableStream<T>,\n) {\n  const isReadableStream =\n    initialValue instanceof ReadableStream ||\n    (typeof initialValue === 'object' &&\n      initialValue !== null &&\n      'getReader' in initialValue &&\n      typeof initialValue.getReader === 'function' &&\n      'locked' in initialValue &&\n      typeof initialValue.locked === 'boolean');\n\n  if (!isReadableStream) {\n    return createStreamableValueImpl<T, E>(initialValue);\n  }\n\n  const streamableValue = createStreamableValueImpl<T, E>();\n\n  // Since the streamable value will be from a readable stream, it's not allowed\n  // to update the value manually as that introduces race conditions and\n  // unexpected behavior.\n  // We lock the value to prevent any updates from the user.\n  streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = true;\n\n  (async () => {\n    try {\n      // Consume the readable stream and update the value.\n      const reader = initialValue.getReader();\n\n      while (true) {\n        const { value, done } = await reader.read();\n        if (done) {\n          break;\n        }\n\n        // Unlock the value to allow updates.\n        streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n        if (typeof value === 'string') {\n          streamableValue.append(value);\n        } else {\n          streamableValue.update(value);\n        }\n        // Lock the value again.\n        streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = true;\n      }\n\n      streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n      streamableValue.done();\n    } catch (e) {\n      streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n      streamableValue.error(e);\n    }\n  })();\n\n  return streamableValue;\n}\n\n// It's necessary to define the type manually here, otherwise TypeScript compiler\n// will not be able to infer the correct return type as it's circular.\ntype StreamableValueWrapper<T, E> = {\n  /**\n   * The value of the streamable. This can be returned from a Server Action and\n   * received by the client. To read the streamed values, use the\n   * `readStreamableValue` or `useStreamableValue` APIs.\n   */\n  readonly value: StreamableValue<T, E>;\n\n  /**\n   * This method updates the current value with a new one.\n   */\n  update(value: T): StreamableValueWrapper<T, E>;\n\n  /**\n   * This method is used to append a delta string to the current value. It\n   * requires the current value of the streamable to be a string.\n   *\n   * @example\n   * ```jsx\n   * const streamable = createStreamableValue('hello');\n   * streamable.append(' world');\n   *\n   * // The value will be 'hello world'\n   * ```\n   */\n  append(value: T): StreamableValueWrapper<T, E>;\n\n  /**\n   * This method is used to signal that there is an error in the value stream.\n   * It will be thrown on the client side when consumed via\n   * `readStreamableValue` or `useStreamableValue`.\n   */\n  error(error: any): StreamableValueWrapper<T, E>;\n\n  /**\n   * This method marks the value as finalized. You can either call it without\n   * any parameters or with a new value as the final state.\n   * Once called, the value cannot be updated or appended anymore.\n   *\n   * This method is always **required** to be called, otherwise the response\n   * will be stuck in a loading state.\n   */\n  done(...args: [T] | []): StreamableValueWrapper<T, E>;\n\n  /**\n   * @internal This is an internal lock to prevent the value from being\n   * updated by the user.\n   */\n  [STREAMABLE_VALUE_INTERNAL_LOCK]: boolean;\n};\n\nfunction createStreamableValueImpl<T = any, E = any>(initialValue?: T) {\n  let closed = false;\n  let locked = false;\n  let resolvable = createResolvablePromise<StreamableValue<T, E>>();\n\n  let currentValue = initialValue;\n  let currentError: E | undefined;\n  let currentPromise: typeof resolvable.promise | undefined =\n    resolvable.promise;\n  let currentPatchValue: StreamablePatch;\n\n  function assertStream(method: string) {\n    if (closed) {\n      throw new Error(method + ': Value stream is already closed.');\n    }\n    if (locked) {\n      throw new Error(\n        method + ': Value stream is locked and cannot be updated.',\n      );\n    }\n  }\n\n  let warningTimeout: NodeJS.Timeout | undefined;\n  function warnUnclosedStream() {\n    if (process.env.NODE_ENV === 'development') {\n      if (warningTimeout) {\n        clearTimeout(warningTimeout);\n      }\n      warningTimeout = setTimeout(() => {\n        console.warn(\n          'The streamable value has been slow to update. This may be a bug or a performance issue or you forgot to call `.done()`.',\n        );\n      }, HANGING_STREAM_WARNING_TIME_MS);\n    }\n  }\n  warnUnclosedStream();\n\n  function createWrapped(initialChunk?: boolean): StreamableValue<T, E> {\n    // This makes the payload much smaller if there're mutative updates before the first read.\n    let init: Partial<StreamableValue<T, E>>;\n\n    if (currentError !== undefined) {\n      init = { error: currentError };\n    } else {\n      if (currentPatchValue && !initialChunk) {\n        init = { diff: currentPatchValue };\n      } else {\n        init = { curr: currentValue };\n      }\n    }\n\n    if (currentPromise) {\n      init.next = currentPromise;\n    }\n\n    if (initialChunk) {\n      init.type = STREAMABLE_VALUE_TYPE;\n    }\n\n    return init;\n  }\n\n  // Update the internal `currentValue` and `currentPatchValue` if needed.\n  function updateValueStates(value: T) {\n    // If we can only send a patch over the wire, it's better to do so.\n    currentPatchValue = undefined;\n    if (typeof value === 'string') {\n      if (typeof currentValue === 'string') {\n        if (value.startsWith(currentValue)) {\n          currentPatchValue = [0, value.slice(currentValue.length)];\n        }\n      }\n    }\n\n    currentValue = value;\n  }\n\n  const streamable: StreamableValueWrapper<T, E> = {\n    set [STREAMABLE_VALUE_INTERNAL_LOCK](state: boolean) {\n      locked = state;\n    },\n    get value() {\n      return createWrapped(true);\n    },\n    update(value: T) {\n      assertStream('.update()');\n\n      const resolvePrevious = resolvable.resolve;\n      resolvable = createResolvablePromise();\n\n      updateValueStates(value);\n      currentPromise = resolvable.promise;\n      resolvePrevious(createWrapped());\n\n      warnUnclosedStream();\n\n      return streamable;\n    },\n    append(value: T) {\n      assertStream('.append()');\n\n      if (\n        typeof currentValue !== 'string' &&\n        typeof currentValue !== 'undefined'\n      ) {\n        throw new Error(\n          `.append(): The current value is not a string. Received: ${typeof currentValue}`,\n        );\n      }\n      if (typeof value !== 'string') {\n        throw new Error(\n          `.append(): The value is not a string. Received: ${typeof value}`,\n        );\n      }\n\n      const resolvePrevious = resolvable.resolve;\n      resolvable = createResolvablePromise();\n\n      if (typeof currentValue === 'string') {\n        currentPatchValue = [0, value];\n        (currentValue as string) = currentValue + value;\n      } else {\n        currentPatchValue = undefined;\n        currentValue = value;\n      }\n\n      currentPromise = resolvable.promise;\n      resolvePrevious(createWrapped());\n\n      warnUnclosedStream();\n\n      return streamable;\n    },\n    error(error: any) {\n      assertStream('.error()');\n\n      if (warningTimeout) {\n        clearTimeout(warningTimeout);\n      }\n      closed = true;\n      currentError = error;\n      currentPromise = undefined;\n\n      resolvable.resolve({ error });\n\n      return streamable;\n    },\n    done(...args: [] | [T]) {\n      assertStream('.done()');\n\n      if (warningTimeout) {\n        clearTimeout(warningTimeout);\n      }\n      closed = true;\n      currentPromise = undefined;\n\n      if (args.length) {\n        updateValueStates(args[0]);\n        resolvable.resolve(createWrapped());\n        return streamable;\n      }\n\n      resolvable.resolve({});\n\n      return streamable;\n    },\n  };\n\n  return streamable;\n}\n\nexport { createStreamableValue };\n"],"names":["_a","name","marker","symbol","AISDKError","z","getErrorMessage","jsx","streamable","render","formatStreamPart","value"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACSO,SAAS;IAKd,IAAI;IACJ,IAAI;IAEJ,MAAM,UAAU,IAAI,QAAW,CAAC,KAAK;QACnC,UAAU;QACV,SAAS;IACX;IAEA,OAAO;QACL;QACA;QACA;IACF;AACF;;ACrBO,IAAM,aAAa,CAAC,QACzB,OAAO,UAAU;;AFOnB,IAAM,sBAAsB,IAAI,8CAAA,CAAA,oBAAA;AAShC,SAAS,uBAAuB,OAAA;IAC9B,MAAM,QAAQ,oBAAoB,QAAA;IAClC,IAAI,CAAC,OAAO;QACV,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT;AAEO,SAAS,YACd,EAAE,OAAA,MAAA,EAAO,OAAA,EAAQ,EACjB,EAAA;IAEA,OAAO,oBAAoB,GAAA,CACzB;QACE,cAAc;QACd,eAAe;QACf,QAAQ;QACR;IACF,GACA;AAEJ;AAEO,SAAS;IACd,MAAM,QAAQ,uBAAuB;IACrC,OAAO,MAAM,oBAAA;AACf;AAKO,SAAS;IACd,MAAM,QAAQ,uBAAuB;IACrC,MAAM,MAAA,GAAS;AACjB;AAgBA,SAAS,WAAA,GACJ,IAAA;IAEH,MAAM,QAAQ,uBACZ;IAGF,IAAI,KAAK,MAAA,GAAS,GAAG;QACnB,MAAM,MAAM,IAAA,CAAK,EAAC;QAClB,IAAI,OAAO,MAAM,YAAA,KAAiB,UAAU;YAC1C,MAAM,IAAI,MACR,CAAA,mBAAA,EAAsB,OACpB,KACD,qDAAA,CAAA;QAEL;QACA,OAAO,MAAM,YAAA,CAAa,IAAsC;IAClE;IAEA,OAAO,MAAM,YAAA;AACf;AA0BA,SAAS,kBAAA,GACJ,IAAA;IAQH,MAAM,QAAQ,uBACZ;IAGF,IAAI,MAAM,MAAA,EAAQ;QAChB,MAAM,IAAI,MACR;IAEJ;IAEA,IAAI,CAAC,MAAM,oBAAA,EAAsB;QAC/B,MAAM,EAAE,OAAA,EAAS,OAAA,EAAQ,GAAI;QAC7B,MAAM,oBAAA,GAAuB;QAC7B,MAAM,oBAAA,GAAuB;IAC/B;IAEA,SAAS,SAAS,QAAA,EAA6B,IAAA;QAhJjD,IAAAA,KAAA;QAiJI,IAAI,KAAK,MAAA,GAAS,GAAG;YACnB,IAAI,OAAO,MAAM,YAAA,KAAiB,UAAU;gBAC1C,MAAM,MAAM,IAAA,CAAK,EAAC;gBAClB,MAAM,IAAI,MACR,CAAA,sBAAA,EAAyB,OACvB,KACD,mDAAA,CAAA;YAEL;QACF;QAEA,IAAI,WAAW,WAAW;YACxB,IAAI,KAAK,MAAA,GAAS,GAAG;gBACnB,MAAM,YAAA,CAAa,IAAA,CAAK,EAAE,CAAA,GAAI,SAAS,MAAM,YAAA,CAAa,IAAA,CAAK,EAAE,CAAC;YACpE,OAAO;gBACL,MAAM,YAAA,GAAe,SAAS,MAAM,YAAY;YAClD;QACF,OAAO;YACL,IAAI,KAAK,MAAA,GAAS,GAAG;gBACnB,MAAM,YAAA,CAAa,IAAA,CAAK,EAAE,CAAA,GAAI;YAChC,OAAO;gBACL,MAAM,YAAA,GAAe;YACvB;QACF;QAEA,CAAA,KAAA,CAAAA,MAAA,MAAM,OAAA,EAAQ,YAAA,KAAd,OAAA,KAAA,IAAA,GAAA,IAAA,CAAAA,KAA6B;YAC3B,KAAK,KAAK,MAAA,GAAS,IAAI,IAAA,CAAK,EAAC,GAAI,KAAA;YACjC,OAAO,MAAM,YAAA;YACb;QACF;IACF;IAEA,MAAM,eAAe;QACnB,KAAK;YACH,IAAI,KAAK,MAAA,GAAS,GAAG;gBACnB,MAAM,MAAM,IAAA,CAAK,EAAC;gBAClB,IAAI,OAAO,MAAM,YAAA,KAAiB,UAAU;oBAC1C,MAAM,IAAI,MACR,CAAA,mBAAA,EAAsB,OACpB,KACD,qDAAA,CAAA;gBAEL;gBACA,OAAO,MAAM,YAAA,CAAa,IAAG;YAC/B;YAEA,OAAO,MAAM,YAAA;QACf;QACA,QAAQ,SAAS,OAAO,UAAA;YACtB,SAAS,YAAY;QACvB;QACA,MAAM,SAAS,KAAA,GAAQ,QAAA;YACrB,IAAI,SAAS,MAAA,GAAS,GAAG;gBACvB,SAAS,QAAA,CAAS,EAAC,EAAwB;YAC7C;YAEA,MAAM,QAAsB,wNAAA,IAAA,CAAK,MAAM,aAAA,EAAe,MAAM,YAAY;YACxE,MAAM,oBAAA,CAAsB;QAC9B;IACF;IAEA,OAAO;AACT;;;;IG5Le;AAAf,0BACE,EACE,MAAA,EACA,OAAA,EACF,EACA,MAAA,EAAA,GACG,IAAA;IAGH,OAAO,MAAM,YACX;QACE,OAAA;QACA;IACF,GACA;QACE,MAAM,SAAS,MAAM,UAAU;QAC/B;QACA,OAAO;YAAC;YAAwC;SAAM;IACxD;AAEJ;AAEA,SAAS,WACP,MAAA,EACA,OAAA;IAEA,OAAO,YAAY,IAAA,CAAK,MAAM;QAAE;QAAQ;IAAQ;AAClD;AAEO,SAAS,SAId,EACA,OAAA,EACA,cAAA,EACA,cAAA,EAEA,YAAA,EACA,YAAA,EACF;IA0CE,MAAM,iBAAuC,CAAC;IAC9C,IAAA,MAAWC,SAAQ,QAAS;QAC1B,cAAA,CAAeA,MAAI,GAAI,WAAW,OAAA,CAAQA,MAAI,EAAG;YAC/C;QACF;IACF;IAEA,MAAM,qBAAqB,eACvB,WAAW,cAAc,CAAC,KAC1B,KAAA;IAEJ,MAAM,KAA4C,OAAM;QAhH1D,IAAAD,KAAA;QAiHI,IAAI,cAAc,wXAAO;YAIvB,MAAM,IAAI,MACR;QAEJ;QAEA,IAAI,UAAA,CAAUA,MAAA,MAAM,cAAA,KAAN,OAAAA,MAAwB;QACtC,IAAI,UAAA,CAAU,KAAA,MAAM,cAAA,KAAN,OAAA,KAAwB;QACtC,IAAI,eAAe,KAAA;QAEnB,IAAI,oBAAoB;YACtB,MAAM,CAAC,iBAAiB,WAAU,GAAI,MAAM,mBAAmB;YAC/D,IAAI,eAAe,KAAA,GAAW;gBAC5B,eAAe;gBACf,UAAU;YACZ;QACF;QAEA,OACE,aAAA,GAAA,CAAA,GAAA,wYAAA,CAAA,MAAA,EAAC,iXAAA,CAAA,qBAAA,EAAA;YACC;YACA;YACA,gBAAgB;YAChB,gBAAgB;YAChB,qBAAqB;YAEpB,UAAA,MAAM,QAAA;QAAA;IAGb;IAEA,OAAO;AACT;;;;AGlJA,IAAM,OAAO;AACb,IAAM,SAAS,CAAA,gBAAA,EAAmB,KAAI,CAAA;AACtC,IAAM,SAAS,OAAO,GAAA,CAAI;AAJ1B,IAAA;AAMO,IAAM,gBAAN,cAA4B,8NAAA,CAAA,aAAA;IAOjC,YAAY,EACV,GAAA,EACA,UAAA,EACA,UAAA,EACA,KAAA,EACA,UAAU,SAAS,OACf,CAAA,mBAAA,EAAsB,IAAG,EAAA,EAAK,WAAU,CAAA,EAAI,WAAU,CAAA,GACtD,CAAA,mBAAA,EAAsB,IAAG,EAAA,EAAK,MAAK,CAAA,EACzC,CAMG;QACD,KAAA,CAAM;YAAE;YAAM;YAAS;QAAM;QArB/B,IAAA,CAAkB,GAAA,GAAU;QAuB1B,IAAA,CAAK,GAAA,GAAM;QACX,IAAA,CAAK,UAAA,GAAa;QAClB,IAAA,CAAK,UAAA,GAAa;IACpB;IAEA,OAAO,WAAW,KAAA,EAAwC;QACxD,OAAO,8NAAA,CAAA,aAAA,CAAW,SAAA,CAAU,OAAO;IACrC;IAAA;;GAAA,GAKA,OAAO,gBAAgB,KAAA,EAAwC;QAC7D,OACE,iBAAiB,SACjB,MAAM,IAAA,KAAS,QACf,OAAQ,MAAwB,GAAA,KAAQ,YAAA,CACtC,MAAwB,UAAA,IAAc,QACtC,OAAQ,MAAwB,UAAA,KAAe,QAAA,KAAA,CAC/C,MAAwB,UAAA,IAAc,QACtC,OAAQ,MAAwB,UAAA,KAAe,QAAA;IAErD;IAAA;;GAAA,GAKA,SAAS;QACP,OAAO;YACL,MAAM,IAAA,CAAK,IAAA;YACX,SAAS,IAAA,CAAK,OAAA;YACd,KAAK,IAAA,CAAK,GAAA;YACV,YAAY,IAAA,CAAK,UAAA;YACjB,YAAY,IAAA,CAAK,UAAA;YACjB,OAAO,IAAA,CAAK,KAAA;QACd;IACF;AACF;AA5DoB,KAAA;;ACLpB,eAAsB,SAAS,EAC7B,GAAA,EACA,sBAAsB,KAAA,EACxB;IALA,IAAAA;IAYE,MAAM,UAAU,IAAI,QAAA;IACpB,IAAI;QACF,MAAM,WAAW,MAAM,oBAAoB;QAE3C,IAAI,CAAC,SAAS,EAAA,EAAI;YAChB,MAAM,IAAI,cAAc;gBACtB,KAAK;gBACL,YAAY,SAAS,MAAA;gBACrB,YAAY,SAAS,UAAA;YACvB;QACF;QAEA,OAAO;YACL,MAAM,IAAI,WAAW,MAAM,SAAS,WAAA;YACpC,UAAA,CAAUA,MAAA,SAAS,OAAA,CAAQ,GAAA,CAAI,eAAc,KAAnC,OAAAA,MAAwC,KAAA;QACpD;IACF,EAAA,OAAS,OAAO;QACd,IAAI,cAAc,UAAA,CAAW,QAAQ;YACnC,MAAM;QACR;QAEA,MAAM,IAAI,cAAc;YAAE,KAAK;YAAS,OAAO;QAAM;IACvD;AACF;;ACnCA,IAAM,qBAAqB;IACzB;QAAE,UAAU;QAAsB,OAAO;YAAC;YAAM;YAAM;SAAI;IAAE;IAC5D;QAAE,UAAU;QAAsB,OAAO;YAAC;YAAM;YAAM;YAAM;SAAI;IAAE;IAClE;QAAE,UAAU;QAAuB,OAAO;YAAC;YAAM;SAAI;IAAE;IACvD;QAAE,UAAU;QAAuB,OAAO;YAAC;YAAM;YAAM;YAAM;SAAI;IAAE;CACrE;AAEO,SAAS,oBACd,KAAA;IAEA,KAAA,MAAW,EAAE,KAAA,EAAO,QAAA,EAAS,IAAK,mBAAoB;QACpD,IACE,MAAM,MAAA,IAAU,MAAM,MAAA,IACtB,MAAM,KAAA,CAAM,CAAC,MAAM,QAAU,KAAA,CAAM,MAAK,KAAM,OAC9C;YACA,OAAO;QACT;IACF;IAEA,OAAO,KAAA;AACT;;;AElBA,IAAMC,QAAO;AACb,IAAMC,UAAS,CAAA,gBAAA,EAAmBD,MAAI,CAAA;AACtC,IAAME,UAAS,OAAO,GAAA,CAAID;AAJ1B,IAAAF;AAMO,IAAM,0BAAN,cAAsCI,8NAAAA,CAAAA,aAAAA;IAK3C,YAAY,EACV,OAAA,EACA,KAAA,EACA,UAAU,CAAA,4FAAA,EAA+F,OAAO,QAAO,CAAA,CAAA,EACzH,CAIG;QACD,KAAA,CAAM;YAAE,MAAAH;YAAM;YAAS;QAAM;QAb/B,IAAA,CAAkBD,IAAAA,GAAU;QAe1B,IAAA,CAAK,OAAA,GAAU;IACjB;IAEA,OAAO,WAAW,KAAA,EAAkD;QAClE,OAAOI,8NAAAA,CAAAA,aAAAA,CAAW,SAAA,CAAU,OAAOF;IACrC;IAAA;;GAAA,GAKA,OAAO,0BACL,KAAA,EACkC;QAClC,OACE,iBAAiB,SACjB,MAAM,IAAA,KAASD,SACd,MAAkC,OAAA,IAAW;IAElD;IAAA;;GAAA,GAKA,SAAS;QACP,OAAO;YACL,MAAM,IAAA,CAAK,IAAA;YACX,SAAS,IAAA,CAAK,OAAA;YACd,OAAO,IAAA,CAAK,KAAA;YACZ,OAAO,IAAA,CAAK,KAAA;YACZ,SAAS,IAAA,CAAK,OAAA;QAChB;IACF;AACF;AA/CoBD,MAAAG;;ADQb,IAAM,oBAA4C,qLAAA,CAAA,IAAA,CAAE,KAAA,CAAM;IAC/D,qLAAA,CAAA,IAAA,CAAE,MAAA;IACF,qLAAA,CAAA,IAAA,CAAE,UAAA,CAAW;IACb,qLAAA,CAAA,IAAA,CAAE,UAAA,CAAW;IACb,qLAAA,CAAA,IAAA,CAAE,MAAA,CAAA,yEAAA;IAEA,CAAC;QArBL,IAAAH,KAAA;QAsBM,OAAA,CAAA,KAAA,CAAAA,MAAA,WAAW,MAAA,KAAX,OAAA,KAAA,IAAAA,IAAmB,QAAA,CAAS,MAAA,KAA5B,OAAA,KAAsC;IAAA,GACxC;QAAE,SAAS;IAAmB;CAEjC;AA0BM,SAAS,+BACd,OAAA;IAEA,IAAI,mBAAmB,YAAY;QACjC,OAAO;IACT;IAEA,IAAI,OAAO,YAAY,UAAU;QAC/B,IAAI;YACF,OAAO,CAAA,GAAA,oQAAA,CAAA,4BAAA,EAA0B;QACnC,EAAA,OAAS,OAAO;YACd,MAAM,IAAI,wBAAwB;gBAChC,SACE;gBACF;gBACA,OAAO;YACT;QACF;IACF;IAEA,IAAI,mBAAmB,aAAa;QAClC,OAAO,IAAI,WAAW;IACxB;IAEA,MAAM,IAAI,wBAAwB;QAAE;IAAQ;AAC9C;;AE1EA,IAAMC,QAAO;AACb,IAAMC,UAAS,CAAA,gBAAA,EAAmBD,MAAI,CAAA;AACtC,IAAME,UAAS,OAAO,GAAA,CAAID;AAJ1B,IAAAF;AAMO,IAAM,0BAAN,cAAsCI,8NAAAA,CAAAA,aAAAA;IAK3C,YAAY,EACV,IAAA,EACA,UAAU,CAAA,uBAAA,EAA0B,KAAI,yDAAA,CAAA,EAC1C,CAGG;QACD,KAAA,CAAM;YAAE,MAAAH;YAAM;QAAQ;QAXxB,IAAA,CAAkBD,IAAAA,GAAU;QAa1B,IAAA,CAAK,IAAA,GAAO;IACd;IAEA,OAAO,WAAW,KAAA,EAAkD;QAClE,OAAOI,8NAAAA,CAAAA,aAAAA,CAAW,SAAA,CAAU,OAAOF;IACrC;IAAA;;GAAA,GAKA,OAAO,0BACL,KAAA,EACkC;QAClC,OACE,iBAAiB,SACjB,MAAM,IAAA,KAASD,SACf,OAAQ,MAAkC,IAAA,KAAS;IAEvD;IAAA;;GAAA,GAKA,SAAS;QACP,OAAO;YACL,MAAM,IAAA,CAAK,IAAA;YACX,SAAS,IAAA,CAAK,OAAA;YACd,OAAO,IAAA,CAAK,KAAA;YAEZ,MAAM,IAAA,CAAK,IAAA;QACb;IACF;AACF;AA7CoBD,MAAAG;;ANQpB,eAAsB,6BAA6B,EACjD,MAAA,EACA,yBAAyB,IAAA,EACzB,yBAAyB,QAAA,EAC3B;IAKE,MAAM,wBAA+C,EAAC;IAEtD,IAAI,OAAO,MAAA,IAAU,MAAM;QACzB,sBAAsB,IAAA,CAAK;YAAE,MAAM;YAAU,SAAS,OAAO,MAAA;QAAO;IACtE;IAEA,MAAM,mBACJ,0BAA0B,OAAO,QAAA,IAAY,OACzC,OACA,MAAM,eAAe,OAAO,QAAA,EAAU;IAE5C,MAAM,aAAa,OAAO,IAAA;IAC1B,OAAQ;QACN,KAAK;YAAU;gBACb,sBAAsB,IAAA,CAAK;oBACzB,MAAM;oBACN,SAAS;wBAAC;4BAAE,MAAM;4BAAQ,MAAM,OAAO,MAAA;wBAAO;qBAAC;gBACjD;gBACA;YACF;QAEA,KAAK;YAAY;gBACf,sBAAsB,IAAA,IACjB,OAAO,QAAA,CAAS,GAAA,CACjB,CAAC,UACC,8BAA8B,SAAS;gBAG7C;YACF;QAEA;YAAS;gBACP,MAAM,mBAA0B;gBAChC,MAAM,IAAI,MAAM,CAAA,yBAAA,EAA4B,iBAAgB,CAAE;YAChE;IACF;IAEA,OAAO;AACT;AASO,SAAS,8BACd,OAAA,EACA,gBAAA;IAKA,MAAM,OAAO,QAAQ,IAAA;IACrB,OAAQ;QACN,KAAK;YAAU;gBACb,OAAO;oBACL,MAAM;oBACN,SAAS,QAAQ,OAAA;oBACjB,kBAAkB,QAAQ,6BAAA;gBAC5B;YACF;QAEA,KAAK;YAAQ;gBACX,IAAI,OAAO,QAAQ,OAAA,KAAY,UAAU;oBACvC,OAAO;wBACL,MAAM;wBACN,SAAS;4BAAC;gCAAE,MAAM;gCAAQ,MAAM,QAAQ,OAAA;4BAAQ;yBAAC;wBACjD,kBAAkB,QAAQ,6BAAA;oBAC5B;gBACF;gBAEA,OAAO;oBACL,MAAM;oBACN,SAAS,QAAQ,OAAA,CAAQ,GAAA,CACvB,CAAC;wBApGX,IAAAH,KAAA,IAAA;wBAqGY,OAAQ,KAAK,IAAA;4BACX,KAAK;gCAAQ;oCACX,OAAO;wCACL,MAAM;wCACN,MAAM,KAAK,IAAA;wCACX,kBAAkB,KAAK,6BAAA;oCACzB;gCACF;4BAEA,KAAK;gCAAS;oCACZ,IAAI,KAAK,KAAA,YAAiB,KAAK;wCAC7B,IAAI,oBAAoB,MAAM;4CAC5B,OAAO;gDACL,MAAM;gDACN,OAAO,KAAK,KAAA;gDACZ,UAAU,KAAK,QAAA;gDACf,kBAAkB,KAAK,6BAAA;4CACzB;wCACF,OAAO;4CACL,MAAM,kBACJ,gBAAA,CAAiB,KAAK,KAAA,CAAM,QAAA,GAAU;4CACxC,OAAO;gDACL,MAAM;gDACN,OAAO,gBAAgB,IAAA;gDACvB,UAAA,CAAUA,MAAA,KAAK,QAAA,KAAL,OAAAA,MAAiB,gBAAgB,QAAA;gDAC3C,kBAAkB,KAAK,6BAAA;4CACzB;wCACF;oCACF;oCAGA,IAAI,OAAO,KAAK,KAAA,KAAU,UAAU;wCAClC,IAAI;4CACF,MAAM,MAAM,IAAI,IAAI,KAAK,KAAK;4CAE9B,OAAQ,IAAI,QAAA;gDACV,KAAK;gDACL,KAAK;oDAAU;wDACb,IAAI,oBAAoB,MAAM;4DAC5B,OAAO;gEACL,MAAM;gEACN,OAAO;gEACP,UAAU,KAAK,QAAA;gEACf,kBACE,KAAK,6BAAA;4DACT;wDACF,OAAO;4DACL,MAAM,kBAAkB,gBAAA,CAAiB,KAAK,KAAK,CAAA;4DACnD,OAAO;gEACL,MAAM;gEACN,OAAO,gBAAgB,IAAA;gEACvB,UAAA,CAAU,KAAA,KAAK,QAAA,KAAL,OAAA,KAAiB,gBAAgB,QAAA;gEAC3C,kBACE,KAAK,6BAAA;4DACT;wDACF;oDACF;gDACA,KAAK;oDAAS;wDACZ,IAAI;4DACF,MAAM,CAAC,QAAQ,cAAa,GAAI,KAAK,KAAA,CAAM,KAAA,CAAM;4DACjD,MAAM,WAAW,OAAO,KAAA,CAAM,IAAG,CAAE,EAAC,CAAE,KAAA,CAAM,IAAG,CAAE,EAAC;4DAElD,IAAI,YAAY,QAAQ,iBAAiB,MAAM;gEAC7C,MAAM,IAAI,MAAM;4DAClB;4DAEA,OAAO;gEACL,MAAM;gEACN,OACE,+BAA+B;gEACjC;gEACA,kBACE,KAAK,6BAAA;4DACT;wDACF,EAAA,OAAS,OAAO;4DACd,MAAM,IAAI,MACR,CAAA,2BAAA,EAA8B,CAAA,GAAA,oQAAA,CAAA,kBAAA,EAC5B,SACD,CAAA;wDAEL;oDACF;gDACA;oDAAS;wDACP,MAAM,IAAI,MACR,CAAA,0BAAA,EAA6B,IAAI,QAAQ,CAAA,CAAA;oDAE7C;4CACF;wCACF,EAAA,OAAS,UAAU,CAEnB;oCACF;oCAEA,MAAM,aAAa,+BAA+B,KAAK,KAAK;oCAE5D,OAAO;wCACL,MAAM;wCACN,OAAO;wCACP,UAAA,CAAU,KAAA,KAAK,QAAA,KAAL,OAAA,KAAiB,oBAAoB;wCAC/C,kBAAkB,KAAK,6BAAA;oCACzB;gCACF;wBACF;oBACF;oBAEF,kBAAkB,QAAQ,6BAAA;gBAC5B;YACF;QAEA,KAAK;YAAa;gBAChB,IAAI,OAAO,QAAQ,OAAA,KAAY,UAAU;oBACvC,OAAO;wBACL,MAAM;wBACN,SAAS;4BAAC;gCAAE,MAAM;gCAAQ,MAAM,QAAQ,OAAA;4BAAQ;yBAAC;wBACjD,kBAAkB,QAAQ,6BAAA;oBAC5B;gBACF;gBAEA,OAAO;oBACL,MAAM;oBACN,SAAS,QAAQ,OAAA,CAAQ,MAAA,CAAA,2BAAA;oBAEvB,CAAA,OAAQ,KAAK,IAAA,KAAS,UAAU,KAAK,IAAA,KAAS;oBAEhD,kBAAkB,QAAQ,6BAAA;gBAC5B;YACF;QAEA,KAAK;YAAQ;gBACX,OAAO;oBACL,MAAM;oBACN,SAAS,QAAQ,OAAA,CAAQ,GAAA,CAAI,CAAA,OAAA,CAAS;4BACpC,MAAM;4BACN,YAAY,KAAK,UAAA;4BACjB,UAAU,KAAK,QAAA;4BACf,QAAQ,KAAK,MAAA;4BACb,kBAAkB,KAAK,6BAAA;wBACzB,CAAA;oBACA,kBAAkB,QAAQ,6BAAA;gBAC5B;YACF;QAEA;YAAS;gBACP,MAAM,mBAA0B;gBAChC,MAAM,IAAI,wBAAwB;oBAAE,MAAM;gBAAiB;YAC7D;IACF;AACF;AAEA,eAAe,eACb,QAAA,EACA,sBAAA;IAEA,MAAM,OAAO,SACV,MAAA,CAAO,CAAA,UAAW,QAAQ,IAAA,KAAS,QACnC,GAAA,CAAI,CAAA,UAAW,QAAQ,OAAO,EAC9B,MAAA,CAAO,CAAC,UACP,MAAM,OAAA,CAAQ,UAEf,IAAA,GACA,MAAA,CAAO,CAAC,OAA4B,KAAK,IAAA,KAAS,SAClD,GAAA,CAAI,CAAA,OAAQ,KAAK,KAAK,EACtB,GAAA,CAAI,CAAA,OAAA,sCAAA;QAEH,OAAO,SAAS,YAAA,CACf,KAAK,UAAA,CAAW,YAAY,KAAK,UAAA,CAAW,SAAQ,IACjD,IAAI,IAAI,QACR,MAEL,MAAA,CAAO,CAAC,QAAwB,iBAAiB;IAGpD,MAAM,mBAAmB,MAAM,QAAQ,GAAA,CACrC,KAAK,GAAA,CAAI,OAAM,MAAA,CAAQ;YACrB;YACA,MAAM,MAAM,uBAAuB;gBAAE;YAAI;QAC3C,CAAA;IAGF,OAAO,OAAO,WAAA,CACZ,iBAAiB,GAAA,CAAI,CAAC,EAAE,GAAA,EAAK,IAAA,EAAK,GAAM;YAAC,IAAI,QAAA;YAAY;SAAK;AAElE;;AOzRA,IAAMC,QAAO;AACb,IAAMC,UAAS,CAAA,gBAAA,EAAmBD,MAAI,CAAA;AACtC,IAAME,UAAS,OAAO,GAAA,CAAID;AAJ1B,IAAAF;AAMO,IAAM,uBAAN,cAAmCI,8NAAAA,CAAAA,aAAAA;IAMxC,YAAY,EACV,SAAA,EACA,KAAA,EACA,OAAA,EACF,CAIG;QACD,KAAA,CAAM;YACJ,MAAAH;YACA,SAAS,CAAA,+BAAA,EAAkC,UAAS,EAAA,EAAK,QAAO,CAAA;QAClE;QAjBF,IAAA,CAAkBD,IAAAA,GAAU;QAmB1B,IAAA,CAAK,SAAA,GAAY;QACjB,IAAA,CAAK,KAAA,GAAQ;IACf;IAEA,OAAO,WAAW,KAAA,EAA+C;QAC/D,OAAOI,8NAAAA,CAAAA,aAAAA,CAAW,SAAA,CAAU,OAAOF;IACrC;IAAA;;GAAA,GAKA,OAAO,uBAAuB,KAAA,EAA+C;QAC3E,OACE,iBAAiB,SACjB,MAAM,IAAA,KAASD,SACf,OAAQ,MAA+B,SAAA,KAAc,YACrD,OAAQ,MAA+B,KAAA,KAAU;IAErD;IAEA,SAAS;QACP,OAAO;YACL,MAAM,IAAA,CAAK,IAAA;YACX,SAAS,IAAA,CAAK,OAAA;YACd,OAAO,IAAA,CAAK,KAAA;YAEZ,WAAW,IAAA,CAAK,SAAA;YAChB,OAAO,IAAA,CAAK,KAAA;QACd;IACF;AACF;AAjDoBD,MAAAG;;ACDb,SAAS,oBAAoB,EAClC,SAAA,EACA,WAAA,EACA,IAAA,EACA,eAAA,EACA,gBAAA,EACA,aAAA,EACA,IAAA,EACA,UAAA,EACF;IACE,IAAI,aAAa,MAAM;QACrB,IAAI,CAAC,OAAO,SAAA,CAAU,YAAY;YAChC,MAAM,IAAI,qBAAqB;gBAC7B,WAAW;gBACX,OAAO;gBACP,SAAS;YACX;QACF;QAEA,IAAI,YAAY,GAAG;YACjB,MAAM,IAAI,qBAAqB;gBAC7B,WAAW;gBACX,OAAO;gBACP,SAAS;YACX;QACF;IACF;IAEA,IAAI,eAAe,MAAM;QACvB,IAAI,OAAO,gBAAgB,UAAU;YACnC,MAAM,IAAI,qBAAqB;gBAC7B,WAAW;gBACX,OAAO;gBACP,SAAS;YACX;QACF;IACF;IAEA,IAAI,QAAQ,MAAM;QAChB,IAAI,OAAO,SAAS,UAAU;YAC5B,MAAM,IAAI,qBAAqB;gBAC7B,WAAW;gBACX,OAAO;gBACP,SAAS;YACX;QACF;IACF;IAEA,IAAI,mBAAmB,MAAM;QAC3B,IAAI,OAAO,oBAAoB,UAAU;YACvC,MAAM,IAAI,qBAAqB;gBAC7B,WAAW;gBACX,OAAO;gBACP,SAAS;YACX;QACF;IACF;IAEA,IAAI,oBAAoB,MAAM;QAC5B,IAAI,OAAO,qBAAqB,UAAU;YACxC,MAAM,IAAI,qBAAqB;gBAC7B,WAAW;gBACX,OAAO;gBACP,SAAS;YACX;QACF;IACF;IAEA,IAAI,QAAQ,MAAM;QAChB,IAAI,CAAC,OAAO,SAAA,CAAU,OAAO;YAC3B,MAAM,IAAI,qBAAqB;gBAC7B,WAAW;gBACX,OAAO;gBACP,SAAS;YACX;QACF;IACF;IAEA,IAAI,cAAc,MAAM;QACtB,IAAI,CAAC,OAAO,SAAA,CAAU,aAAa;YACjC,MAAM,IAAI,qBAAqB;gBAC7B,WAAW;gBACX,OAAO;gBACP,SAAS;YACX;QACF;QAEA,IAAI,aAAa,GAAG;YAClB,MAAM,IAAI,qBAAqB;gBAC7B,WAAW;gBACX,OAAO;gBACP,SAAS;YACX;QACF;IACF;IAEA,OAAO;QACL;QACA,aAAa,eAAA,OAAA,cAAe;QAC5B;QACA;QACA;QACA,eACE,iBAAiB,QAAQ,cAAc,MAAA,GAAS,IAC5C,gBACA,KAAA;QACN;QACA,YAAY,cAAA,OAAA,aAAc;IAC5B;AACF;;;AEnHO,SAAS,iBACd,MAAA;IAEA,OAAO,UAAU,QAAQ,OAAO,IAAA,CAAK,QAAQ,MAAA,GAAS;AACxD;;ADKO,SAAS,0BAEd,EACA,KAAA,EACA,UAAA,EACF;IAOE,IAAI,CAAC,iBAAiB,QAAQ;QAC5B,OAAO;YACL,OAAO,KAAA;YACP,YAAY,KAAA;QACd;IACF;IAEA,OAAO;QACL,OAAO,OAAO,OAAA,CAAQ,OAAO,GAAA,CAAI,CAAC,CAACF,OAAM,KAAI,GAAA,CAAO;gBAClD,MAAM;gBACN,MAAAA;gBACA,aAAa,KAAK,WAAA;gBAClB,YAAY,CAAA,GAAA,wQAAA,CAAA,WAAA,EAAS,KAAK,UAAU,EAAE,UAAA;YACxC,CAAA;QACA,YACE,cAAc,OACV;YAAE,MAAM;QAAO,IACf,OAAO,eAAe,WACtB;YAAE,MAAM;QAAW,IACnB;YAAE,MAAM;YAAiB,UAAU,WAAW,QAAA;QAAmB;IACzE;AACF;;;;;;;AKvCO,IAAM,kBAAwCI,qLAAAA,CAAAA,IAAAA,CAAE,IAAA,CAAK,IAC1DA,qLAAAA,CAAAA,IAAAA,CAAE,KAAA,CAAM;QACNA,qLAAAA,CAAAA,IAAAA,CAAE,IAAA;QACFA,qLAAAA,CAAAA,IAAAA,CAAE,MAAA;QACFA,qLAAAA,CAAAA,IAAAA,CAAE,MAAA;QACFA,qLAAAA,CAAAA,IAAAA,CAAE,OAAA;QACFA,qLAAAA,CAAAA,IAAAA,CAAE,MAAA,CAAOA,qLAAAA,CAAAA,IAAAA,CAAE,MAAA,IAAU;QACrBA,qLAAAA,CAAAA,IAAAA,CAAE,KAAA,CAAM;KACT;;ADAI,IAAM,yBAAsDA,qLAAAA,CAAAA,IAAAA,CAAE,MAAA,CACnEA,qLAAAA,CAAAA,IAAAA,CAAE,MAAA,IACFA,qLAAAA,CAAAA,IAAAA,CAAE,MAAA,CAAOA,qLAAAA,CAAAA,IAAAA,CAAE,MAAA,IAAU;;AEahB,IAAM,iBAAsCA,qLAAAA,CAAAA,IAAAA,CAAE,MAAA,CAAO;IAC1D,MAAMA,qLAAAA,CAAAA,IAAAA,CAAE,OAAA,CAAQ;IAChB,MAAMA,qLAAAA,CAAAA,IAAAA,CAAE,MAAA;IACR,+BAA+B,uBAAuB,QAAA;AACxD;AA6BO,IAAM,kBAAwCA,qLAAAA,CAAAA,IAAAA,CAAE,MAAA,CAAO;IAC5D,MAAMA,qLAAAA,CAAAA,IAAAA,CAAE,OAAA,CAAQ;IAChB,OAAOA,qLAAAA,CAAAA,IAAAA,CAAE,KAAA,CAAM;QAAC;QAAmBA,qLAAAA,CAAAA,IAAAA,CAAE,UAAA,CAAW;KAAK;IACrD,UAAUA,qLAAAA,CAAAA,IAAAA,CAAE,MAAA,GAAS,QAAA;IACrB,+BAA+B,uBAAuB,QAAA;AACxD;AAwBO,IAAM,qBAA8CA,qLAAAA,CAAAA,IAAAA,CAAE,MAAA,CAAO;IAClE,MAAMA,qLAAAA,CAAAA,IAAAA,CAAE,OAAA,CAAQ;IAChB,YAAYA,qLAAAA,CAAAA,IAAAA,CAAE,MAAA;IACd,UAAUA,qLAAAA,CAAAA,IAAAA,CAAE,MAAA;IACZ,MAAMA,qLAAAA,CAAAA,IAAAA,CAAE,OAAA;AACV;AAoCO,IAAM,uBAAkDA,qLAAAA,CAAAA,IAAAA,CAAE,MAAA,CAAO;IACtE,MAAMA,qLAAAA,CAAAA,IAAAA,CAAE,OAAA,CAAQ;IAChB,YAAYA,qLAAAA,CAAAA,IAAAA,CAAE,MAAA;IACd,UAAUA,qLAAAA,CAAAA,IAAAA,CAAE,MAAA;IACZ,QAAQA,qLAAAA,CAAAA,IAAAA,CAAE,OAAA;IACV,SAASA,qLAAAA,CAAAA,IAAAA,CAAE,OAAA,GAAU,QAAA;IACrB,+BAA+B,uBAAuB,QAAA;AACxD;;AHvGO,IAAM,0BAAwDA,qLAAAA,CAAAA,IAAAA,CAAE,MAAA,CAAO;IAC5E,MAAMA,qLAAAA,CAAAA,IAAAA,CAAE,OAAA,CAAQ;IAChB,SAASA,qLAAAA,CAAAA,IAAAA,CAAE,MAAA;IACX,+BAA+B,uBAAuB,QAAA;AACxD;AAsBO,IAAM,wBAAoDA,qLAAAA,CAAAA,IAAAA,CAAE,MAAA,CAAO;IACxE,MAAMA,qLAAAA,CAAAA,IAAAA,CAAE,OAAA,CAAQ;IAChB,SAASA,qLAAAA,CAAAA,IAAAA,CAAE,KAAA,CAAM;QACfA,qLAAAA,CAAAA,IAAAA,CAAE,MAAA;QACFA,qLAAAA,CAAAA,IAAAA,CAAE,KAAA,CAAMA,qLAAAA,CAAAA,IAAAA,CAAE,KAAA,CAAM;YAAC;YAAgB;SAAgB;KAClD;IACD,+BAA+B,uBAAuB,QAAA;AACxD;AA2BO,IAAM,6BACXA,qLAAAA,CAAAA,IAAAA,CAAE,MAAA,CAAO;IACP,MAAMA,qLAAAA,CAAAA,IAAAA,CAAE,OAAA,CAAQ;IAChB,SAASA,qLAAAA,CAAAA,IAAAA,CAAE,KAAA,CAAM;QACfA,qLAAAA,CAAAA,IAAAA,CAAE,MAAA;QACFA,qLAAAA,CAAAA,IAAAA,CAAE,KAAA,CAAMA,qLAAAA,CAAAA,IAAAA,CAAE,KAAA,CAAM;YAAC;YAAgB;SAAmB;KACrD;IACD,+BAA+B,uBAAuB,QAAA;AACxD;AA2BK,IAAM,wBAAoDA,qLAAAA,CAAAA,IAAAA,CAAE,MAAA,CAAO;IACxE,MAAMA,qLAAAA,CAAAA,IAAAA,CAAE,OAAA,CAAQ;IAChB,SAASA,qLAAAA,CAAAA,IAAAA,CAAE,KAAA,CAAM;IACjB,+BAA+B,uBAAuB,QAAA;AACxD;AAsBO,IAAM,oBAA4CA,qLAAAA,CAAAA,IAAAA,CAAE,KAAA,CAAM;IAC/D;IACA;IACA;IACA;CACD;;AD3IM,SAAS,eAAe,MAAA;IAC7B,IAAI,OAAO,MAAA,IAAU,QAAQ,OAAO,QAAA,IAAY,MAAM;QACpD,MAAM,IAAI,8NAAA,CAAA,qBAAA,CAAmB;YAC3B;YACA,SAAS;QACX;IACF;IAEA,IAAI,OAAO,MAAA,IAAU,QAAQ,OAAO,QAAA,IAAY,MAAM;QACpD,MAAM,IAAI,8NAAA,CAAA,qBAAA,CAAmB;YAC3B;YACA,SAAS;QACX;IACF;IAGA,IAAI,OAAO,MAAA,IAAU,QAAQ,OAAO,OAAO,MAAA,KAAW,UAAU;QAC9D,MAAM,IAAI,8NAAA,CAAA,qBAAA,CAAmB;YAC3B;YACA,SAAS;QACX;IACF;IAGA,IAAI,OAAO,MAAA,IAAU,MAAM;QAEzB,IAAI,OAAO,OAAO,MAAA,KAAW,UAAU;YACrC,MAAM,IAAI,8NAAA,CAAA,qBAAA,CAAmB;gBAC3B;gBACA,SAAS;YACX;QACF;QAEA,OAAO;YACL,MAAM;YACN,QAAQ,OAAO,MAAA;YACf,UAAU,KAAA;YACV,QAAQ,OAAO,MAAA;QACjB;IACF;IAGA,IAAI,OAAO,QAAA,IAAY,MAAM;QAC3B,MAAM,mBAAmB,CAAA,GAAA,oQAAA,CAAA,oBAAA,EAAkB;YACzC,OAAO,OAAO,QAAA;YACd,QAAQA,qLAAAA,CAAAA,IAAAA,CAAE,KAAA,CAAM;QAClB;QAEA,IAAI,CAAC,iBAAiB,OAAA,EAAS;YAC7B,MAAM,IAAI,8NAAA,CAAA,qBAAA,CAAmB;gBAC3B;gBACA,SAAS;gBACT,OAAO,iBAAiB,KAAA;YAC1B;QACF;QAEA,OAAO;YACL,MAAM;YACN,QAAQ,KAAA;YACR,UAAU,OAAO,QAAA;YAAA,wCAAA;YACjB,QAAQ,OAAO,MAAA;QACjB;IACF;IAEA,MAAM,IAAI,MAAM;AAClB;;AKvDO,SAAS,8BAA8B,KAAA;IAI5C,OAAO;QACL,cAAc,MAAM,YAAA;QACpB,kBAAkB,MAAM,gBAAA;QACxB,aAAa,MAAM,YAAA,GAAe,MAAM,gBAAA;IAC1C;AACF;;ACrCA,IAAMJ,QAAO;AACb,IAAMC,UAAS,CAAA,gBAAA,EAAmBD,MAAI,CAAA;AACtC,IAAME,UAAS,OAAO,GAAA,CAAID;AAJ1B,IAAAF;AAMO,IAAM,4BAAN,cAAwCI,8NAAAA,CAAAA,aAAAA;IAM7C,YAAY,EACV,QAAA,EACA,QAAA,EACA,KAAA,EACA,UAAU,CAAA,2BAAA,EAA8B,SAAQ,EAAA,EAAKE,CAAAA,GAAAA,8NAAAA,CAAAA,kBAAAA,EACnD,OACD,CAAA,EACH,CAKG;QACD,KAAA,CAAM;YAAE,MAAAL;YAAM;YAAS;QAAM;QAlB/B,IAAA,CAAkBD,IAAAA,GAAU;QAoB1B,IAAA,CAAK,QAAA,GAAW;QAChB,IAAA,CAAK,QAAA,GAAW;IAClB;IAEA,OAAO,WAAW,KAAA,EAAoD;QACpE,OAAOI,8NAAAA,CAAAA,aAAAA,CAAW,SAAA,CAAU,OAAOF;IACrC;IAAA;;GAAA,GAKA,OAAO,4BACL,KAAA,EACoC;QACpC,OACE,iBAAiB,SACjB,MAAM,IAAA,KAASD,SACf,OAAQ,MAAoC,QAAA,KAAa,YACzD,OAAQ,MAAoC,QAAA,KAAa;IAE7D;IAAA;;GAAA,GAKA,SAAS;QACP,OAAO;YACL,MAAM,IAAA,CAAK,IAAA;YACX,SAAS,IAAA,CAAK,OAAA;YACd,OAAO,IAAA,CAAK,KAAA;YACZ,OAAO,IAAA,CAAK,KAAA;YAEZ,UAAU,IAAA,CAAK,QAAA;YACf,UAAU,IAAA,CAAK,QAAA;QACjB;IACF;AACF;AAxDoBD,MAAAG;;ACLpB,IAAMF,QAAO;AACb,IAAMC,UAAS,CAAA,gBAAA,EAAmBD,MAAI,CAAA;AACtC,IAAME,UAAS,OAAO,GAAA,CAAID;AAJ1B,IAAAF;AAMO,IAAM,kBAAN,cAA8BI,8NAAAA,CAAAA,aAAAA;IAMnC,YAAY,EACV,QAAA,EACA,iBAAiB,KAAA,CAAA,EACjB,UAAU,CAAA,sCAAA,EAAyC,SAAQ,GAAA,EACzD,mBAAmB,KAAA,IACf,4BACA,CAAA,iBAAA,EAAoB,eAAe,IAAA,CAAK,MAAK,CAAA,CACnD,CAAA,CAAA,EACF,CAIG;QACD,KAAA,CAAM;YAAE,MAAAH;YAAM;QAAQ;QAlBxB,IAAA,CAAkBD,IAAAA,GAAU;QAoB1B,IAAA,CAAK,QAAA,GAAW;QAChB,IAAA,CAAK,cAAA,GAAiB;IACxB;IAEA,OAAO,WAAW,KAAA,EAA0C;QAC1D,OAAOI,8NAAAA,CAAAA,aAAAA,CAAW,SAAA,CAAU,OAAOF;IACrC;IAAA;;GAAA,GAKA,OAAO,kBAAkB,KAAA,EAA0C;QACjE,OACE,iBAAiB,SACjB,MAAM,IAAA,KAASD,SACf,cAAc,SACd,MAAM,QAAA,IAAY,KAAA,KAClB,OAAO,MAAM,IAAA,KAAS;IAE1B;IAAA;;GAAA,GAKA,SAAS;QACP,OAAO;YACL,MAAM,IAAA,CAAK,IAAA;YACX,SAAS,IAAA,CAAK,OAAA;YACd,OAAO,IAAA,CAAK,KAAA;YAEZ,UAAU,IAAA,CAAK,QAAA;YACf,gBAAgB,IAAA,CAAK,cAAA;QACvB;IACF;AACF;AAtDoBD,MAAAG;;ACPb,SAAS,iBACd,KAAA;IAEA,OACE,SAAS,QAAQ,OAAO,UAAU,YAAY,OAAO,aAAA,IAAiB;AAE1E;;ACNO,SAAS,YACd,KAAA;IAEA,OAAO,SAAS,QAAQ,OAAO,UAAU,YAAY,OAAO,QAAA,IAAY;AAC1E;;;;AEJA,eAAsB,MAAM,SAAA;IAC1B,OAAO,cAAc,KAAA,IACjB,QAAQ,OAAA,KACR,IAAI,QAAQ,CAAA,UAAW,WAAW,SAAS;AACjD;;ACFA,IAAMF,QAAO;AACb,IAAMC,UAAS,CAAA,gBAAA,EAAmBD,MAAI,CAAA;AACtC,IAAME,UAAS,OAAO,GAAA,CAAID;AAJ1B,IAAAF;AAWO,IAAM,aAAN,cAAyBI,8NAAAA,CAAAA,aAAAA;IAQ9B,YAAY,EACV,OAAA,EACA,MAAA,EACA,MAAA,EACF,CAIG;QACD,KAAA,CAAM;YAAE,MAAAH;YAAM;QAAQ;QAhBxB,IAAA,CAAkBD,IAAAA,GAAU;QAkB1B,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,MAAA,GAAS;QAGd,IAAA,CAAK,SAAA,GAAY,MAAA,CAAO,OAAO,MAAA,GAAS,EAAC;IAC3C;IAEA,OAAO,WAAW,KAAA,EAAqC;QACrD,OAAOI,8NAAAA,CAAAA,aAAAA,CAAW,SAAA,CAAU,OAAOF;IACrC;IAAA;;GAAA,GAKA,OAAO,aAAa,KAAA,EAAqC;QACvD,OACE,iBAAiB,SACjB,MAAM,IAAA,KAASD,SACf,OAAQ,MAAqB,MAAA,KAAW,YACxC,MAAM,OAAA,CAAS,MAAqB,MAAM;IAE9C;IAAA;;GAAA,GAKA,SAAS;QACP,OAAO;YACL,MAAM,IAAA,CAAK,IAAA;YACX,SAAS,IAAA,CAAK,OAAA;YACd,QAAQ,IAAA,CAAK,MAAA;YACb,WAAW,IAAA,CAAK,SAAA;YAChB,QAAQ,IAAA,CAAK,MAAA;QACf;IACF;AACF;AArDoBD,MAAAG;;AFCb,IAAM,8BACX,CAAC,EACC,aAAa,CAAA,EACb,mBAAmB,GAAA,EACnB,gBAAgB,CAAA,EAClB,GAAI,CAAC,CAAA,GACL,OAAe,IACb,6BAA6B,GAAG;YAC9B;YACA,WAAW;YACX;QACF;AAEJ,eAAe,6BACb,CAAA,EACA,EACE,UAAA,EACA,SAAA,EACA,aAAA,EACF,EACA,SAAoB,EAAC;IAErB,IAAI;QACF,OAAO,MAAM;IACf,EAAA,OAAS,OAAO;QACd,IAAI,CAAA,GAAA,oQAAA,CAAA,eAAA,EAAa,QAAQ;YACvB,MAAM;QACR;QAEA,IAAI,eAAe,GAAG;YACpB,MAAM;QACR;QAEA,MAAM,eAAeG,CAAAA,GAAAA,oQAAAA,CAAAA,kBAAAA,EAAgB;QACrC,MAAM,YAAY;eAAI;YAAQ;SAAK;QACnC,MAAM,YAAY,UAAU,MAAA;QAE5B,IAAI,YAAY,YAAY;YAC1B,MAAM,IAAI,WAAW;gBACnB,SAAS,CAAA,aAAA,EAAgB,UAAS,uBAAA,EAA0B,aAAY,CAAA;gBACxE,QAAQ;gBACR,QAAQ;YACV;QACF;QAEA,IACE,iBAAiB,SACjB,8NAAA,CAAA,eAAA,CAAa,cAAA,CAAe,UAC5B,MAAM,WAAA,KAAgB,QACtB,aAAa,YACb;YACA,MAAM,MAAM;YACZ,OAAO,6BACL,GACA;gBAAE;gBAAY,WAAW,gBAAgB;gBAAW;YAAc,GAClE;QAEJ;QAEA,IAAI,cAAc,GAAG;YACnB,MAAM;QACR;QAEA,MAAM,IAAI,WAAW;YACnB,SAAS,CAAA,aAAA,EAAgB,UAAS,qCAAA,EAAwC,aAAY,CAAA,CAAA;YACtF,QAAQ;YACR,QAAQ;QACV;IACF;AACF;;AG9EO,IAAM,iCAAiC,KAAK;;;ACenD,IAAM,IAAI;IACP,OAAO,EACN,GAAG,OAAA,EACH,GAAG,IAAA,EACL;QAIE,MAAM,QAAQ,MAAM;QAEpB,IAAI,MAAM,IAAA,EAAM;YACd,OAAO,MAAM,KAAA;QACf;QAEA,IAAI,MAAM,MAAA,EAAQ;YAChB,OACE,aAAA,GAAA,CAAA,GAAA,wYAAA,CAAA,OAAA,EAAA,wYAAA,CAAA,WAAA,EAAA;gBACG,UAAA;oBAAA;oBACD,aAAA,GAAAC,CAAAA,GAAAA,wYAAAA,CAAAA,MAAAA,EAAC,sXAAA,CAAA,WAAA,EAAA;wBAAS,UAAU,MAAM,KAAA;wBACxB,UAAA,aAAA,GAAAA,CAAAA,GAAAA,wYAAAA,CAAAA,MAAAA,EAAC,GAAA;4BAAE,GAAG,MAAM,KAAA;4BAAO,GAAG,MAAM,IAAA;wBAAA;oBAAM;iBACpC;YAAA;QAGN;QAEA,OACE,aAAA,GAAAA,CAAAA,GAAAA,wYAAAA,CAAAA,MAAAA,EAAC,sXAAA,CAAA,WAAA,EAAA;YAAS,UAAU,MAAM,KAAA;YACxB,UAAA,aAAA,GAAAA,CAAAA,GAAAA,wYAAAA,CAAAA,MAAAA,EAAC,GAAA;gBAAE,GAAG,MAAM,KAAA;gBAAO,GAAG,MAAM,IAAA;YAAA;QAAM;IAGxC;CAIF,CAAE,EAAC;AAcI,SAAS,qBAAqB,YAAA;IAKnC,MAAM,EAAE,OAAA,EAAS,OAAA,EAAS,MAAA,EAAO,GAAI;IAErC,OAAO;QACL,KACE,aAAA,GAAAA,CAAAA,GAAAA,wYAAAA,CAAAA,MAAAA,EAAC,sXAAA,CAAA,WAAA,EAAA;YAAS,UAAU;YAClB,UAAA,aAAA,GAAAA,CAAAA,GAAAA,wYAAAA,CAAAA,MAAAA,EAAC,GAAA;gBAAE,GAAG;gBAAc,GAAG;YAAA;QAAS;QAGpC;QACA;IACF;AACF;;AC7BA,SAAS,mBAAmB,YAAA;IAC1B,IAAI,eAAe;IACnB,IAAI,SAAS;IACb,IAAI,EAAE,GAAA,EAAK,OAAA,EAAS,MAAA,EAAO,GAAI,qBAAqB;IAEpD,SAAS,aAAa,MAAA;QACpB,IAAI,QAAQ;YACV,MAAM,IAAI,MAAM,SAAS;QAC3B;IACF;IAEA,IAAI;IACJ,SAAS;QACP,wCAA4C;YAC1C,IAAI,gBAAgB;gBAClB,aAAa;YACf;YACA,iBAAiB,WAAW;gBAC1B,QAAQ,IAAA,CACN;YAEJ,GAAG;QACL;IACF;IACA;IAEA,MAAMC,cAAkC;QACtC,OAAO;QACP,QAAO,KAAA;YACL,aAAa;YAGb,IAAI,UAAU,cAAc;gBAC1B;gBACA,OAAOA;YACT;YAEA,MAAM,aAAa;YACnB,eAAe;YAEf,QAAQ;gBAAE,OAAO;gBAAc,MAAM;gBAAO,MAAM,WAAW,OAAA;YAAQ;YACrE,UAAU,WAAW,OAAA;YACrB,SAAS,WAAW,MAAA;YAEpB;YAEA,OAAOA;QACT;QACA,QAAO,KAAA;YACL,aAAa;YAEb,MAAM,aAAa;YACnB,eAAe;YAEf,QAAQ;gBAAE;gBAAO,MAAM;gBAAO,QAAQ;gBAAM,MAAM,WAAW,OAAA;YAAQ;YACrE,UAAU,WAAW,OAAA;YACrB,SAAS,WAAW,MAAA;YAEpB;YAEA,OAAOA;QACT;QACA,OAAM,KAAA;YACJ,aAAa;YAEb,IAAI,gBAAgB;gBAClB,aAAa;YACf;YACA,SAAS;YACT,OAAO;YAEP,OAAOA;QACT;QACA,MAAA,GAAQ,IAAA;YACN,aAAa;YAEb,IAAI,gBAAgB;gBAClB,aAAa;YACf;YACA,SAAS;YACT,IAAI,KAAK,MAAA,EAAQ;gBACf,QAAQ;oBAAE,OAAO,IAAA,CAAK,EAAC;oBAAG,MAAM;gBAAK;gBACrC,OAAOA;YACT;YACA,QAAQ;gBAAE,OAAO;gBAAc,MAAM;YAAK;YAE1C,OAAOA;QACT;IACF;IAEA,OAAOA;AACT;;A3BzEA,IAAM,sBAAkC,CAAC,EAAE,OAAA,EAAQ,GACjD;AAKF,eAAsB,SAEpB,EACA,KAAA,EACA,KAAA,EACA,UAAA,EACA,MAAA,EACA,MAAA,EACA,QAAA,EACA,UAAA,EACA,WAAA,EACA,OAAA,EACA,OAAA,EACA,IAAA,EACA,QAAA,EACA,GAAG,UACL;IAqDE,IAAI,OAAO,UAAU,UAAU;QAC7B,MAAM,IAAI,MACR;IAEJ;IACA,IAAI,eAAe,UAAU;QAC3B,MAAM,IAAI,MACR;IAEJ;IACA,IAAI,cAAc,UAAU;QAC1B,MAAM,IAAI,MACR;IAEJ;IACA,IAAI,OAAO;QACT,KAAA,MAAW,CAACP,OAAM,KAAI,IAAK,OAAO,OAAA,CAAQ,OAAQ;YAChD,IAAI,YAAY,MAAM;gBACpB,MAAM,IAAI,MACR,6GACEA;YAEN;QACF;IACF;IAEA,MAAM,KAAK,mBAAmB;IAG9B,MAAM,aAAa,QAAQ;IAE3B,IAAI;IAEJ,eAAeQ,QAAO,EACpB,IAAA,EACA,QAAA,EACA,YAAA,EACA,aAAa,KAAA,EACf;QAME,IAAI,CAAC,UAAU;QAKf,MAAM,iBAAiB;QACvB,WAAW,WACP,SAAS,IAAA,CAAK,IAAM,eAAe,OAAO,IAC1C,eAAe,OAAA;QAEnB,MAAM,iBAAiB,YAAY;QAEnC,IAAI,iBAAiB,mBAAmB,YAAY,iBAAiB;YACnE,MAAO,KAAM;gBACX,MAAM,EAAE,IAAA,EAAM,KAAA,EAAM,GAAI,MAAM,eAAe,IAAA;gBAC7C,MAAM,OAAO,MAAM;gBAEnB,IAAI,cAAc,MAAM;oBACtB,aAAa,IAAA,CAAK;gBACpB,OAAO;oBACL,aAAa,MAAA,CAAO;gBACtB;gBAEA,IAAI,MAAM;YACZ;QACF,OAAO;YACL,MAAM,OAAO,MAAM;YAEnB,IAAI,YAAY;gBACd,aAAa,IAAA,CAAK;YACpB,OAAO;gBACL,aAAa,MAAA,CAAO;YACtB;QACF;QAGA,eAAe,OAAA,CAAQ,KAAA;IACzB;IAEA,MAAM,QAAQ,4BAA4B;QAAE;IAAW;IACvD,MAAM,kBAAkB,eAAe;QAAE;QAAQ;QAAQ;IAAS;IAClE,MAAM,SAAS,MAAM,MAAM,UACzB,MAAM,QAAA,CAAS;YACb,MAAM;gBACJ,MAAM;gBACN,GAAG,0BAA0B;oBAAE;oBAAO;gBAAW,EAAC;YACpD;YACA,GAAG,oBAAoB,SAAQ;YAC/B,aAAa,gBAAgB,IAAA;YAC7B,QAAQ,MAAM,6BAA6B;gBACzC,QAAQ;gBACR,wBAAwB,MAAM,iBAAA;YAChC;YACA;YACA;QACF;IAIF,MAAM,CAAC,QAAQ,aAAY,GAAI,OAAO,MAAA,CAAO,GAAA;IAC7C,CAAC;QACC,IAAI;YACF,IAAI,UAAU;YACd,IAAI,cAAc;YAElB,MAAM,SAAS,aAAa,SAAA;YAC5B,MAAO,KAAM;gBACX,MAAM,EAAE,IAAA,EAAM,KAAA,EAAM,GAAI,MAAM,OAAO,IAAA;gBACrC,IAAI,MAAM;gBAEV,OAAQ,MAAM,IAAA;oBACZ,KAAK;wBAAc;4BACjB,WAAW,MAAM,SAAA;4BACjBA,QAAO;gCACL,UAAU;gCACV,MAAM;oCAAC;wCAAE;wCAAS,MAAM;wCAAO,OAAO,MAAM,SAAA;oCAAU;iCAAC;gCACvD,cAAc;4BAChB;4BACA;wBACF;oBAEA,KAAK;wBAAmB;4BACtB,cAAc;4BACd;wBACF;oBAEA,KAAK;wBAAa;4BAChB,MAAM,WAAW,MAAM,QAAA;4BAEvB,IAAI,CAAC,OAAO;gCACV,MAAM,IAAI,gBAAgB;oCAAE;gCAAS;4BACvC;4BAEA,MAAM,OAAO,KAAA,CAAM,SAAQ;4BAC3B,IAAI,CAAC,MAAM;gCACT,MAAM,IAAI,gBAAgB;oCACxB;oCACA,gBAAgB,OAAO,IAAA,CAAK;gCAC9B;4BACF;4BAEA,cAAc;4BACd,MAAM,cAAc,CAAA,GAAA,oQAAA,CAAA,gBAAA,EAAc;gCAChC,MAAM,MAAM,IAAA;gCACZ,QAAQ,KAAK,UAAA;4BACf;4BAEA,IAAI,YAAY,OAAA,KAAY,OAAO;gCACjC,MAAM,IAAI,0BAA0B;oCAClC;oCACA,UAAU,MAAM,IAAA;oCAChB,OAAO,YAAY,KAAA;gCACrB;4BACF;4BAEAA,QAAO;gCACL,UAAU,KAAK,QAAA;gCACf,MAAM;oCACJ,YAAY,KAAA;oCACZ;wCACE;wCACA,YAAY,MAAM,UAAA;oCACpB;iCACF;gCACA,cAAc;gCACd,YAAY;4BACd;4BAEA;wBACF;oBAEA,KAAK;wBAAS;4BACZ,MAAM,MAAM,KAAA;wBACd;oBAEA,KAAK;wBAAU;4BACb,YAAA,OAAA,KAAA,IAAA,SAAW;gCACT,cAAc,MAAM,YAAA;gCACpB,OAAO,8BAA8B,MAAM,KAAK;gCAChD,OAAO,GAAG,KAAA;gCACV,UAAU,OAAO,QAAA;gCACjB,aAAa,OAAO,WAAA;4BACtB;wBACF;gBACF;YACF;YAEA,IAAI,CAAC,aAAa;gBAChBA,QAAO;oBACL,UAAU;oBACV,MAAM;wBAAC;4BAAE;4BAAS,MAAM;wBAAK;qBAAC;oBAC9B,cAAc;oBACd,YAAY;gBACd;YACF;YAEA,MAAM;QACR,EAAA,OAAS,OAAO;YAGd,GAAG,KAAA,CAAM;QACX;IACF,CAAA;IAEA,OAAO;QACL,GAAG,MAAA;QACH;QACA,OAAO,GAAG,KAAA;IACZ;AACF;;;A6B/RO,SAAS,6BACd,YAAA;IAEA,MAAM,cAAc,IAAI;IACxB,IAAI;IAEJ,OAAO,IAAI,gBAAgB;QACzB,MAAM,OAAM,UAAA;YACV,oBAAoB,CAAA,GAAA,wNAAA,CAAA,eAAA,EAClB,CAAC;gBACC,IACG,UAAU,SACT,MAAM,IAAA,KAAS,WACf,MAAM,IAAA,KAAS,YAAA,6DAAA;gBAAA,4CAAA;gBAGhB,MAAc,KAAA,KAAU,QACzB;oBACA,WAAW,SAAA;oBACX;gBACF;gBAEA,IAAI,UAAU,OAAO;oBACnB,MAAM,gBAAgB,eAClB,aAAa,MAAM,IAAA,EAAM;wBACvB,OAAO,MAAM,KAAA;oBACf,KACA,MAAM,IAAA;oBACV,IAAI,eAAe,WAAW,OAAA,CAAQ;gBACxC;YACF;QAEJ;QAEA,WAAU,KAAA;YACR,kBAAkB,IAAA,CAAK,YAAY,MAAA,CAAO;QAC5C;IACF;AACF;AAwBO,SAAS,2BACd,EAAA;IAEA,MAAM,cAAc,IAAI;IACxB,IAAI,qBAAqB;IACzB,MAAM,YAAY,MAAM,CAAC;IAEzB,OAAO,IAAI,gBAAgB;QACzB,MAAM;YACJ,IAAI,UAAU,OAAA,EAAS,MAAM,UAAU,OAAA;QACzC;QAEA,MAAM,WAAU,OAAA,EAAS,UAAA;YACvB,MAAM,UAAU,OAAO,YAAY,WAAW,UAAU,QAAQ,OAAA;YAEhE,WAAW,OAAA,CAAQ,YAAY,MAAA,CAAO;YAEtC,sBAAsB;YAEtB,IAAI,UAAU,OAAA,EAAS,MAAM,UAAU,OAAA,CAAQ;YAC/C,IAAI,UAAU,MAAA,IAAU,OAAO,YAAY,UAAU;gBACnD,MAAM,UAAU,MAAA,CAAO;YACzB;QACF;QAEA,MAAM;YACJ,MAAM,oBAAoB,8BAA8B;YAGxD,IAAI,UAAU,YAAA,EAAc;gBAC1B,MAAM,UAAU,YAAA,CAAa;YAC/B;YAEA,IAAI,UAAU,OAAA,IAAW,CAAC,mBAAmB;gBAC3C,MAAM,UAAU,OAAA,CAAQ;YAC1B;QACF;IACF;AACF;AAEA,SAAS,8BACP,SAAA;IAEA,OAAO,iCAAiC;AAC1C;AAgBO,SAAS;IACd,IAAI,gBAAgB;IAEpB,OAAO,CAAC;QACN,IAAI,eAAe;YACjB,OAAO,KAAK,SAAA;YACZ,IAAI,MAAM,gBAAgB;QAC5B;QACA,OAAO;IACT;AACF;AAoBO,SAAS,SACd,QAAA,EACA,YAAA,EACA,SAAA;IAEA,IAAI,CAAC,SAAS,EAAA,EAAI;QAChB,IAAI,SAAS,IAAA,EAAM;YACjB,MAAM,SAAS,SAAS,IAAA,CAAK,SAAA;YAC7B,OAAO,IAAI,eAAe;gBACxB,MAAM,OAAM,UAAA;oBACV,MAAM,EAAE,IAAA,EAAM,KAAA,EAAM,GAAI,MAAM,OAAO,IAAA;oBACrC,IAAI,CAAC,MAAM;wBACT,MAAM,YAAY,IAAI,cAAc,MAAA,CAAO;wBAC3C,WAAW,KAAA,CAAM,IAAI,MAAM,CAAA,gBAAA,EAAmB,UAAS,CAAE;oBAC3D;gBACF;YACF;QACF,OAAO;YACL,OAAO,IAAI,eAAe;gBACxB,OAAM,UAAA;oBACJ,WAAW,KAAA,CAAM,IAAI,MAAM;gBAC7B;YACF;QACF;IACF;IAEA,MAAM,qBAAqB,SAAS,IAAA,IAAQ;IAE5C,OAAO,mBACJ,WAAA,CAAY,6BAA6B,eACzC,WAAA,CAAY,2BAA2B;AAC5C;AAeA,SAAS;IACP,OAAO,IAAI,eAAe;QACxB,OAAM,UAAA;YACJ,WAAW,KAAA;QACb;IACF;AACF;AAMO,SAAS,0BAA6B,QAAA;IAC3C,IAAI,KAAK,QAAA,CAAS,OAAO,aAAa,CAAA;IACtC,OAAO,IAAI,eAAkB;QAC3B,MAAM,MAAK,UAAA;YACT,MAAM,EAAE,IAAA,EAAM,KAAA,EAAM,GAAI,MAAM,GAAG,IAAA;YACjC,IAAI,MAAM,WAAW,KAAA;iBAChB,WAAW,OAAA,CAAQ;QAC1B;QAEA,MAAM,QAAO,MAAA;YApSjB,IAAAT;YAqSM,MAAA,CAAA,CAAMA,MAAA,GAAG,MAAA,KAAH,OAAA,KAAA,IAAAA,IAAA,IAAA,CAAA,IAAY,OAAA;QACpB;IACF;AACF;;AC7MO,SAAS;IACd,MAAM,UAAU,IAAI;IACpB,MAAM,UAAU,IAAI;IACpB,OAAO,IAAI,gBAAgB;QACzB,WAAW,OAAO,OAAO;YACvB,MAAM,UAAU,QAAQ,MAAA,CAAO;YAC/B,WAAW,OAAA,CAAQ,QAAQ,MAAA,CAAO,CAAA,GAAA,wQAAA,CAAA,mBAAA,EAAiB,QAAQ;QAC7D;IACF;AACF;;ACyKA,SAAS;IAGP,MAAM,UAAU;IAChB,OAAO,CAAA,OAAQ,QAAQ,KAAK,KAAA,CAAM;AACpC;AAOA,gBAAgB,WAAW,MAAA;IACzB,MAAM,UAAU;IAEhB,WAAA,IAAe,SAAS,OAAQ;QAG9B,IAAI,yBAAyB,OAAO;YAClC,QAAQ;gBACN,IAAI,MAAM,EAAA;gBACV,SAAS,MAAM,OAAA,CAAQ,OAAA;gBACvB,QAAS,MAAc,MAAA;gBAAA,2BAAA;gBACvB,OAAQ,MAAc,KAAA;gBAAA,2BAAA;gBACtB,SAAS,MAAM,OAAA,CAAQ,GAAA,CAAI,CAAA;oBArSnC,IAAAA,KAAA,IAAA,IAAA,IAAA,IAAA,IAAA;oBAqS8C,OAAA;wBACpC,OAAO;4BACL,SAAA,CAASA,MAAA,OAAO,KAAA,KAAP,OAAA,KAAA,IAAAA,IAAc,OAAA;4BACvB,eAAA,CAAe,KAAA,OAAO,KAAA,KAAP,OAAA,KAAA,IAAA,GAAc,YAAA;4BAC7B,MAAA,CAAM,KAAA,OAAO,KAAA,KAAP,OAAA,KAAA,IAAA,GAAc,IAAA;4BACpB,YAAA,CAAA,CAAY,KAAA,CAAA,KAAA,OAAO,KAAA,KAAP,OAAA,KAAA,IAAA,GAAc,SAAA,KAAd,OAAA,KAAA,IAAA,GAAyB,MAAA,IAAA,CACjC,KAAA,CAAA,KAAA,OAAO,KAAA,KAAP,OAAA,KAAA,IAAA,GAAc,SAAA,KAAd,OAAA,KAAA,IAAA,GAAyB,GAAA,CAAI,CAAC,UAAU,QAAA,CAAW;oCACjD;oCACA,IAAI,SAAS,EAAA;oCACb,UAAU,SAAS,QAAA;oCACnB,MAAM,SAAS,IAAA;gCACjB,CAAA,KACA,KAAA;wBACN;wBACA,eAAe,OAAO,YAAA;wBACtB,OAAO,OAAO,KAAA;oBAChB;gBAAA;YACF;QACF;QAEA,MAAM,OAAO,QAAQ;QAErB,IAAI,MAAM,MAAM;IAClB;AACF;AAEA,SAAS;IAGP,MAAM,oBAAoB;IAC1B,IAAI;IACJ,OAAO,CAAA;QApUT,IAAAA,KAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA;QAqUI,IAAI,sBAAsB,OAAO;YAC/B,MAAM,QAAA,CAAQA,MAAA,KAAK,OAAA,CAAQ,EAAC,KAAd,OAAA,KAAA,IAAAA,IAAiB,KAAA;YAC/B,IAAA,CAAI,KAAA,MAAM,aAAA,KAAN,OAAA,KAAA,IAAA,GAAqB,IAAA,EAAM;gBAC7B,wBAAwB;gBACxB,OAAO;oBACL,QAAQ;oBACR,SAAS,CAAA,4BAAA,EAA+B,MAAM,aAAA,CAAc,IAAI,CAAA,iBAAA,CAAA;gBAClE;YACF,OAAA,IAAA,CAAW,KAAA,CAAA,KAAA,CAAA,KAAA,MAAM,UAAA,KAAN,OAAA,KAAA,IAAA,EAAA,CAAmB,EAAA,KAAnB,OAAA,KAAA,IAAA,GAAuB,QAAA,KAAvB,OAAA,KAAA,IAAA,GAAiC,IAAA,EAAM;gBAChD,wBAAwB;gBACxB,MAAM,WAAW,MAAM,UAAA,CAAW,EAAC;gBACnC,IAAI,SAAS,KAAA,KAAU,GAAG;oBACxB,OAAO;wBACL,QAAQ;wBACR,SAAS,CAAA,wBAAA,EAA2B,SAAS,EAAE,CAAA,6CAAA,EAAA,CAAgD,KAAA,SAAS,QAAA,KAAT,OAAA,KAAA,IAAA,GAAmB,IAAI,CAAA,iBAAA,CAAA;oBACxH;gBACF,OAAO;oBACL,OAAO;wBACL,QAAQ;wBACR,SAAS,CAAA,aAAA,EAAgB,SAAS,EAAE,CAAA,6CAAA,EAAA,CAAgD,KAAA,SAAS,QAAA,KAAT,OAAA,KAAA,IAAA,GAAmB,IAAI,CAAA,iBAAA,CAAA;oBAC7G;gBACF;YACF,OAAA,IAAA,CAAW,KAAA,MAAM,aAAA,KAAN,OAAA,KAAA,IAAA,GAAqB,SAAA,EAAW;gBACzC,OAAO;oBACL,QAAQ;oBACR,SAAS,iBAAA,CAAiB,KAAA,MAAM,aAAA,KAAN,OAAA,KAAA,IAAA,GAAqB,SAAS;gBAC1D;YACF,OAAA,IAAA,CAAW,KAAA,CAAA,KAAA,CAAA,KAAA,MAAM,UAAA,KAAN,OAAA,KAAA,IAAA,EAAA,CAAmB,EAAA,KAAnB,OAAA,KAAA,IAAA,GAAuB,QAAA,KAAvB,OAAA,KAAA,IAAA,GAAiC,SAAA,EAAW;gBACrD,OAAO;oBACL,QAAQ;oBACR,SAAS,iBAAA,CAAiB,KAAA,CAAA,KAAA,CAAA,KAAA,MAAM,UAAA,KAAN,OAAA,KAAA,IAAA,EAAA,CAAmB,EAAA,KAAnB,OAAA,KAAA,IAAA,GAAuB,QAAA,KAAvB,OAAA,KAAA,IAAA,GAAiC,SAAS;gBACtE;YACF,OAAA,IACE,yBAAA,CAAA,CAAA,CACC,KAAA,KAAK,OAAA,CAAQ,EAAC,KAAd,OAAA,KAAA,IAAA,GAAiB,aAAA,MAAkB,mBAAA,CAAA,CAClC,KAAA,KAAK,OAAA,CAAQ,EAAC,KAAd,OAAA,KAAA,IAAA,GAAiB,aAAA,MAAkB,MAAA,GACrC;gBACA,wBAAwB;gBACxB,OAAO;oBACL,QAAQ;oBACR,SAAS;gBACX;YACF,OAAA,IACE,yBAAA,CAAA,CACA,KAAA,KAAK,OAAA,CAAQ,EAAC,KAAd,OAAA,KAAA,IAAA,GAAiB,aAAA,MAAkB,cACnC;gBACA,wBAAwB;gBACxB,OAAO;oBACL,QAAQ;oBACR,SAAS;gBACX;YACF;QACF;QAEA,MAAM,OAAO,kBACX,sBAAsB,SAAS,KAAK,OAAA,CAAQ,EAAC,CAAE,KAAA,CAAM,OAAA,GACjD,KAAK,OAAA,CAAQ,EAAC,CAAE,KAAA,CAAM,OAAA,GACtB,aAAa,QACb,KAAK,OAAA,CAAQ,EAAC,CAAE,IAAA,GAChB;QAGN,OAAO;IACT;IAEA,SAAS,iBAAiB,aAAA;QACxB,IAAI,qBAAqB,cACtB,OAAA,CAAQ,OAAO,QACf,OAAA,CAAQ,OAAO,OACf,OAAA,CAAQ,MAAM,OACd,OAAA,CAAQ,OAAO,OACf,OAAA,CAAQ,OAAO,OACf,OAAA,CAAQ,OAAO,OACf,OAAA,CAAQ,OAAO;QAElB,OAAO,CAAA,EAAG,mBAAkB,CAAA;IAC9B;AACF;AAEA,IAAM,qCAAqC,OACzC;AAaF,SAAS,sBACP,IAAA;IAEA,OACE,aAAa,QACb,KAAK,OAAA,IACL,KAAK,OAAA,CAAQ,EAAC,IACd,WAAW,KAAK,OAAA,CAAQ,EAAC;AAE7B;AAEA,SAAS,aAAa,IAAA;IACpB,OACE,aAAa,QACb,KAAK,OAAA,IACL,KAAK,OAAA,CAAQ,EAAC,IACd,UAAU,KAAK,OAAA,CAAQ,EAAC;AAE5B;AAKO,SAAS,aACd,GAAA,EACA,SAAA;IAGA,MAAM,KAIG;IAET,IAAI;IACJ,IAAI,OAAO,aAAA,IAAiB,KAAK;QAC/B,SAAS,0BAA0B,WAAW,MAAM,WAAA,CAClD,2BAAA,CACE,MAAA,OAAA,KAAA,IAAA,GAAI,2BAAA,KAAA,CAA+B,MAAA,OAAA,KAAA,IAAA,GAAI,uBAAA,IACnC;YACE,GAAG,EAAA;YACH,SAAS,KAAA;QACX,IACA;YACE,GAAG,EAAA;QACL;IAGV,OAAO;QACL,SAAS,SACP,KACA,qBAAkB,CAClB,MAAA,OAAA,KAAA,IAAA,GAAI,2BAAA,KAAA,CAA+B,MAAA,OAAA,KAAA,IAAA,GAAI,uBAAA,IACnC;YACE,GAAG,EAAA;YACH,SAAS,KAAA;QACX,IACA;YACE,GAAG,EAAA;QACL;IAER;IAEA,IAAI,MAAA,CAAO,GAAG,2BAAA,IAA+B,GAAG,uBAAA,GAA0B;QACxE,MAAM,0BAA0B,8BAA8B;QAC9D,OAAO,OAAO,WAAA,CAAY;IAC5B,OAAO;QACL,OAAO,OAAO,WAAA,CAAY;IAC5B;AACF;AAEA,SAAS,8BACP,SAAA;IAIA,MAAM,cAAc,IAAI;IACxB,IAAI,eAAe;IACnB,IAAI,qBAAqB;IACzB,IAAI,oCAAoC;IACxC,IAAI,wBAAwB;IAE5B,IAAI,uBACF,SAAA,CAAU,mCAAkC,IAAK,EAAC;IAEpD,MAAM,SAAS,CAAA,GAAA,wQAAA,CAAA,qBAAA;IAEf,OAAO,IAAI,gBAAgB;QACzB,MAAM,WAAU,KAAA,EAAO,UAAA;YACrB,MAAM,UAAU,OAAO;YACvB,qCAAqC;YAErC,MAAM,yBACJ,gBAAA,CACC,QAAQ,UAAA,CAAW,wBAClB,QAAQ,UAAA,CAAW,iBAAgB;YAEvC,IAAI,wBAAwB;gBAC1B,wBAAwB;gBACxB,sBAAsB;gBACtB,eAAe;gBACf;YACF;YAGA,IAAI,CAAC,uBAAuB;gBAC1B,WAAW,OAAA,CACT,YAAY,MAAA,CAAOU,CAAAA,GAAAA,wQAAAA,CAAAA,mBAAAA,EAAiB,QAAQ;gBAE9C;YACF,OAAO;gBACL,sBAAsB;YACxB;QACF;QACA,MAAM,OAAM,UAAA;YACV,IAAI;gBACF,IACE,CAAC,gBACD,yBAAA,CACC,UAAU,2BAAA,IACT,UAAU,uBAAA,GACZ;oBACA,wBAAwB;oBACxB,MAAM,UAAU,KAAK,KAAA,CAAM;oBAE3B,IAAI,0BAA2C;2BAC1C;qBACL;oBAEA,IAAI,mBAMY,KAAA;oBAEhB,IAAI,UAAU,2BAAA,EAA6B;wBAIzC,IAAI,QAAQ,aAAA,KAAkB,KAAA,GAAW;4BACvC,QAAQ,IAAA,CACN;wBAEJ;wBAEA,MAAM,mBAAmB,KAAK,KAAA,CAC5B,QAAQ,aAAA,CAAc,SAAA;wBAGxB,mBAAmB,MAAM,UAAU,2BAAA,CACjC;4BACE,MAAM,QAAQ,aAAA,CAAc,IAAA;4BAC5B,WAAW;wBACb,GACA,CAAA;4BAEE,0BAA0B;mCACrB;gCACH;oCACE,MAAM;oCACN,SAAS;oCACT,eAAe,QAAQ,aAAA;gCACzB;gCACA;oCACE,MAAM;oCACN,MAAM,QAAQ,aAAA,CAAc,IAAA;oCAC5B,SAAS,KAAK,SAAA,CAAU;gCAC1B;6BACF;4BAEA,OAAO;wBACT;oBAEJ;oBACA,IAAI,UAAU,uBAAA,EAAyB;wBACrC,MAAM,YAA6B;4BACjC,OAAO,EAAC;wBACV;wBACA,KAAA,MAAW,QAAQ,QAAQ,UAAA,CAAY;4BACrC,UAAU,KAAA,CAAM,IAAA,CAAK;gCACnB,IAAI,KAAK,EAAA;gCACT,MAAM;gCACN,MAAM;oCACJ,MAAM,KAAK,QAAA,CAAS,IAAA;oCACpB,WAAW,KAAK,KAAA,CAAM,KAAK,QAAA,CAAS,SAAS;gCAC/C;4BACF;wBACF;wBACA,IAAI,gBAAgB;wBACpB,IAAI;4BACF,mBAAmB,MAAM,UAAU,uBAAA,CACjC,WACA,CAAA;gCACE,IAAI,QAAQ;oCACV,MAAM,EAAE,YAAA,EAAc,aAAA,EAAe,gBAAA,EAAiB,GACpD;oCAEF,0BAA0B;2CACrB;wCAAA,+DAAA;2CAEC,kBAAkB,IAClB;4CACE;gDACE,MAAM;gDACN,SAAS;gDACT,YAAY,QAAQ,UAAA,CAAW,GAAA,CAC7B,CAAC,KAAA,CAAkB;wDACjB,IAAI,GAAG,EAAA;wDACP,MAAM;wDACN,UAAU;4DACR,MAAM,GAAG,QAAA,CAAS,IAAA;4DAAA,wGAAA;4DAElB,WAAW,KAAK,SAAA,CACd,GAAG,QAAA,CAAS,SAAA;wDAEhB;oDACF,CAAA;4CAEJ;yCACF,GACA,EAAC;wCAAA,0CAAA;wCAEL;4CACE,MAAM;4CACN;4CACA,MAAM;4CACN,SAAS,KAAK,SAAA,CAAU;wCAC1B;qCACF;oCACA;gCACF;gCAEA,OAAO;4BACT;wBAEJ,EAAA,OAAS,GAAG;4BACV,QAAQ,KAAA,CAAM,0CAA0C;wBAC1D;oBACF;oBAEA,IAAI,CAAC,kBAAkB;wBAIrB,WAAW,OAAA,CACT,YAAY,MAAA,CACVA,CAAAA,GAAAA,wQAAAA,CAAAA,mBAAAA,EACE,QAAQ,aAAA,GAAgB,kBAAkB,cAAA,oCAAA;wBAE1C,KAAK,KAAA,CAAM;wBAIjB;oBACF,OAAA,IAAW,OAAO,qBAAqB,UAAU;wBAE/C,WAAW,OAAA,CACT,YAAY,MAAA,CAAOA,CAAAA,GAAAA,wQAAAA,CAAAA,mBAAAA,EAAiB,QAAQ;wBAE9C,oCAAoC;wBACpC;oBACF;oBAOA,MAAM,oBAA2C;wBAC/C,GAAG,SAAA;wBACH,SAAS,KAAA;oBACX;oBAEA,UAAU,OAAA,GAAU,KAAA;oBAEpB,MAAM,eAAe,aAAa,kBAAkB;wBAClD,GAAG,iBAAA;wBACH,CAAC,mCAAkC,EAAG;oBACxC;oBAEA,MAAM,SAAS,aAAa,SAAA;oBAE5B,MAAO,KAAM;wBACX,MAAM,EAAE,IAAA,EAAM,KAAA,EAAM,GAAI,MAAM,OAAO,IAAA;wBACrC,IAAI,MAAM;4BACR;wBACF;wBACA,WAAW,OAAA,CAAQ;oBACrB;gBACF;YACF,SAAE;gBACA,IAAI,UAAU,OAAA,IAAW,mCAAmC;oBAC1D,MAAM,UAAU,OAAA,CAAQ;gBAC1B;YACF;QACF;IACF;AACF;;ACnsBA,eAAsB,cAAc,MAAA;IAClC,MAAM,SAAS,OAAO,SAAA;IACtB,MAAO,KAAM;QACX,MAAM,EAAE,IAAA,EAAK,GAAI,MAAM,OAAO,IAAA;QAC9B,IAAI,MAAM;IACZ;AACF;;AJSO,SAAS,OAOd,OAAA;IAgDA,MAAM,KAAK,mBAAmB,QAAQ,OAAO;IAG7C,MAAM,OAAO,QAAQ,IAAA,GACjB,QAAQ,IAAA,GACR,CAAC,EAAE,OAAA,EAAQ,GAA2B;IAE1C,MAAM,YAAY,QAAQ,SAAA,GACtB,OAAO,OAAA,CAAQ,QAAQ,SAAS,EAAE,GAAA,CAChC,CAAC,CAACT,OAAM,EAAE,WAAA,EAAa,UAAA,EAAY,CAAA;QACjC,OAAO;YACL,MAAAA;YACA;YACA,YAAY,CAAA,GAAA,gRAAA,CAAA,UAAA,EAAgB;QAC9B;IACF,KAEF,KAAA;IAEJ,MAAM,QAAQ,QAAQ,KAAA,GAClB,OAAO,OAAA,CAAQ,QAAQ,KAAK,EAAE,GAAA,CAC5B,CAAC,CAACA,OAAM,EAAE,WAAA,EAAa,UAAA,EAAY,CAAA;QACjC,OAAO;YACL,MAAM;YACN,UAAU;gBACR,MAAAA;gBACA;gBACA,YAAY,CAAA,GAAA,gRAAA,CAAA,UAAA,EAAgB;YAI9B;QACF;IACF,KAEF,KAAA;IAEJ,IAAI,aAAa,OAAO;QACtB,MAAM,IAAI,MACR;IAEJ;IAEA,IAAI;IAEJ,eAAe,aACb,IAAA,EACA,QAAA,EACA,GAAA;QAEA,IAAI,CAAC,UAAU;QAEf,MAAM,aAAa;QAEnB,IAAI,UAAU;YACZ,WAAW,SAAS,IAAA,CAAK,IAAM,WAAW,OAAO;QACnD,OAAO;YACL,WAAW,WAAW,OAAA;QACxB;QAEA,MAAM,QAAQ,SAAS;QACvB,IACE,iBAAiB,WAChB,SACC,OAAO,UAAU,YACjB,UAAU,SACV,OAAO,MAAM,IAAA,KAAS,YACxB;YACA,MAAM,OAAO,MAAO;YACpB,IAAI,MAAA,CAAO;YACX,WAAW,OAAA,CAAQ,KAAA;QACrB,OAAA,IACE,SACA,OAAO,UAAU,YACjB,OAAO,aAAA,IAAiB,OACxB;YACA,MAAM,KAAK;YAKX,MAAO,KAAM;gBACX,MAAM,EAAE,IAAA,EAAM,OAAAU,MAAAA,EAAM,GAAI,MAAM,GAAG,IAAA;gBACjC,IAAI,MAAA,CAAOA;gBACX,IAAI,MAAM;YACZ;YACA,WAAW,OAAA,CAAQ,KAAA;QACrB,OAAA,IAAW,SAAS,OAAO,UAAU,YAAY,OAAO,QAAA,IAAY,OAAO;YACzE,MAAM,KAAK;YACX,MAAO,KAAM;gBACX,MAAM,EAAE,IAAA,EAAM,OAAAA,MAAAA,EAAM,GAAI,GAAG,IAAA;gBAC3B,IAAI,MAAA,CAAOA;gBACX,IAAI,MAAM;YACZ;YACA,WAAW,OAAA,CAAQ,KAAA;QACrB,OAAO;YACL,IAAI,MAAA,CAAO;YACX,WAAW,OAAA,CAAQ,KAAA;QACrB;IACF;IAEA,CAAC;QACC,IAAI,cAAc;QAClB,IAAI,UAAU;QAEd,cACE,aACG,MAAM,QAAQ,QAAA,CAAS,IAAA,CAAK,WAAA,CAAY,MAAA,CAAO;YAC9C,OAAO,QAAQ,KAAA;YACf,UAAU,QAAQ,QAAA;YAClB,aAAa,QAAQ,WAAA;YACrB,QAAQ;YACR,GAAI,YACA;gBACE;YACF,IACA,CAAC,CAAA;YACL,GAAI,QACA;gBACE;YACF,IACA,CAAC,CAAA;QACP,IACA;YACE,GAAI,YACA;gBACE,MAAM,6BAA4B,mBAAA;oBA9MlD,IAAAX,KAAA;oBA+MkB,cAAc;oBACd,aACE,oBAAoB,SAAA,EAAA,CACpB,KAAA,CAAAA,MAAA,QAAQ,SAAA,KAAR,OAAA,KAAA,IAAAA,GAAAA,CAAoB,oBAAoB,IAAA,CAAA,KAAxC,OAAA,KAAA,IAAA,GACI,MAAA,EACJ;gBAEJ;YACF,IACA,CAAC,CAAA;YACL,GAAI,QACA;gBACE,MAAM,yBAAwB,eAAA;oBA3N9C,IAAAA,KAAA;oBA4NkB,cAAc;oBAGd,KAAA,MAAW,QAAQ,gBAAgB,KAAA,CAAO;wBACxC,aACE,KAAK,IAAA,CAAK,SAAA,EAAA,CACV,KAAA,CAAAA,MAAA,QAAQ,KAAA,KAAR,OAAA,KAAA,IAAAA,GAAAA,CAAgB,KAAK,IAAA,CAAK,IAAA,CAAA,KAA1B,OAAA,KAAA,IAAA,GAAwC,MAAA,EACxC;oBAEJ;gBACF;YACF,IACA,CAAC,CAAA;YACL,QAAO,KAAA;gBACL,WAAW;gBACX,aAAa;oBAAE;oBAAS,MAAM;oBAAO,OAAO;gBAAM,GAAG,MAAM;YAC7D;YACA,MAAM;gBACJ,IAAI,aAAa;oBACf,MAAM;oBACN,GAAG,IAAA;oBACH;gBACF;gBAEA,aAAa;oBAAE;oBAAS,MAAM;gBAAK,GAAG,MAAM;gBAC5C,MAAM;gBACN,GAAG,IAAA;YACL;QACF;IAGN,CAAA;IAEA,OAAO,GAAG,KAAA;AACZ;;AK9PO,IAAM,wBAAwB,OAAO,GAAA,CAAI;;ACQhD,IAAM,iCAAiC,OAAO;AAM9C,SAAS,sBACP,YAAA;IAEA,MAAM,mBACJ,wBAAwB,kBACvB,OAAO,iBAAiB,YACvB,iBAAiB,QACjB,eAAe,gBACf,OAAO,aAAa,SAAA,KAAc,cAClC,YAAY,gBACZ,OAAO,aAAa,MAAA,KAAW;IAEnC,IAAI,CAAC,kBAAkB;QACrB,OAAO,0BAAgC;IACzC;IAEA,MAAM,kBAAkB;IAMxB,eAAA,CAAgB,+BAA8B,GAAI;IAElD,CAAC;QACC,IAAI;YAEF,MAAM,SAAS,aAAa,SAAA;YAE5B,MAAO,KAAM;gBACX,MAAM,EAAE,KAAA,EAAO,IAAA,EAAK,GAAI,MAAM,OAAO,IAAA;gBACrC,IAAI,MAAM;oBACR;gBACF;gBAGA,eAAA,CAAgB,+BAA8B,GAAI;gBAClD,IAAI,OAAO,UAAU,UAAU;oBAC7B,gBAAgB,MAAA,CAAO;gBACzB,OAAO;oBACL,gBAAgB,MAAA,CAAO;gBACzB;gBAEA,eAAA,CAAgB,+BAA8B,GAAI;YACpD;YAEA,eAAA,CAAgB,+BAA8B,GAAI;YAClD,gBAAgB,IAAA;QAClB,EAAA,OAAS,GAAG;YACV,eAAA,CAAgB,+BAA8B,GAAI;YAClD,gBAAgB,KAAA,CAAM;QACxB;IACF,CAAA;IAEA,OAAO;AACT;AAuDA,SAAS,0BAA4C,YAAA;IACnD,IAAI,SAAS;IACb,IAAI,SAAS;IACb,IAAI,aAAa;IAEjB,IAAI,eAAe;IACnB,IAAI;IACJ,IAAI,iBACF,WAAW,OAAA;IACb,IAAI;IAEJ,SAAS,aAAa,MAAA;QACpB,IAAI,QAAQ;YACV,MAAM,IAAI,MAAM,SAAS;QAC3B;QACA,IAAI,QAAQ;YACV,MAAM,IAAI,MACR,SAAS;QAEb;IACF;IAEA,IAAI;IACJ,SAAS;QACP,wCAA4C;YAC1C,IAAI,gBAAgB;gBAClB,aAAa;YACf;YACA,iBAAiB,WAAW;gBAC1B,QAAQ,IAAA,CACN;YAEJ,GAAG;QACL;IACF;IACA;IAEA,SAAS,cAAc,YAAA;QAErB,IAAI;QAEJ,IAAI,iBAAiB,KAAA,GAAW;YAC9B,OAAO;gBAAE,OAAO;YAAa;QAC/B,OAAO;YACL,IAAI,qBAAqB,CAAC,cAAc;gBACtC,OAAO;oBAAE,MAAM;gBAAkB;YACnC,OAAO;gBACL,OAAO;oBAAE,MAAM;gBAAa;YAC9B;QACF;QAEA,IAAI,gBAAgB;YAClB,KAAK,IAAA,GAAO;QACd;QAEA,IAAI,cAAc;YAChB,KAAK,IAAA,GAAO;QACd;QAEA,OAAO;IACT;IAGA,SAAS,kBAAkB,KAAA;QAEzB,oBAAoB,KAAA;QACpB,IAAI,OAAO,UAAU,UAAU;YAC7B,IAAI,OAAO,iBAAiB,UAAU;gBACpC,IAAI,MAAM,UAAA,CAAW,eAAe;oBAClC,oBAAoB;wBAAC;wBAAG,MAAM,KAAA,CAAM,aAAa,MAAM;qBAAC;gBAC1D;YACF;QACF;QAEA,eAAe;IACjB;IAEA,MAAMQ,cAA2C;QAC/C,IAAA,CAAK,+BAA8B,EAAE,MAAgB;YACnD,SAAS;QACX;QACA,IAAI,SAAQ;YACV,OAAO,cAAc;QACvB;QACA,QAAO,KAAA;YACL,aAAa;YAEb,MAAM,kBAAkB,WAAW,OAAA;YACnC,aAAa;YAEb,kBAAkB;YAClB,iBAAiB,WAAW,OAAA;YAC5B,gBAAgB;YAEhB;YAEA,OAAOA;QACT;QACA,QAAO,KAAA;YACL,aAAa;YAEb,IACE,OAAO,iBAAiB,YACxB,OAAO,iBAAiB,aACxB;gBACA,MAAM,IAAI,MACR,CAAA,wDAAA,EAA2D,OAAO,aAAY,CAAA;YAElF;YACA,IAAI,OAAO,UAAU,UAAU;gBAC7B,MAAM,IAAI,MACR,CAAA,gDAAA,EAAmD,OAAO,MAAK,CAAA;YAEnE;YAEA,MAAM,kBAAkB,WAAW,OAAA;YACnC,aAAa;YAEb,IAAI,OAAO,iBAAiB,UAAU;gBACpC,oBAAoB;oBAAC;oBAAG;iBAAK;gBAC5B,eAA0B,eAAe;YAC5C,OAAO;gBACL,oBAAoB,KAAA;gBACpB,eAAe;YACjB;YAEA,iBAAiB,WAAW,OAAA;YAC5B,gBAAgB;YAEhB;YAEA,OAAOA;QACT;QACA,OAAM,KAAA;YACJ,aAAa;YAEb,IAAI,gBAAgB;gBAClB,aAAa;YACf;YACA,SAAS;YACT,eAAe;YACf,iBAAiB,KAAA;YAEjB,WAAW,OAAA,CAAQ;gBAAE;YAAM;YAE3B,OAAOA;QACT;QACA,MAAA,GAAQ,IAAA;YACN,aAAa;YAEb,IAAI,gBAAgB;gBAClB,aAAa;YACf;YACA,SAAS;YACT,iBAAiB,KAAA;YAEjB,IAAI,KAAK,MAAA,EAAQ;gBACf,kBAAkB,IAAA,CAAK,EAAE;gBACzB,WAAW,OAAA,CAAQ;gBACnB,OAAOA;YACT;YAEA,WAAW,OAAA,CAAQ,CAAC;YAEpB,OAAOA;QACT;IACF;IAEA,OAAOA;AACT"}},
    {"offset": {"line": 2185, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2189, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/.next-internal/server/app/(chat)/page/actions.js"],"sourcesContent":["__turbopack_export_value__({\n  '18165312b87b38c8eeea9c03383b142333a1ad1b': (...args) => Promise.resolve(require('ACTIONS_MODULE0')).then(mod => (0, mod['getChat'])(...args)),\n  '31009c7e4eb3a1734f1c375d268a8d7fb6265461': (...args) => Promise.resolve(require('ACTIONS_MODULE0')).then(mod => (0, mod['removeChat'])(...args)),\n  '41c0dcd5c5291966abcf0a0b596c982656f90cec': (...args) => Promise.resolve(require('ACTIONS_MODULE1')).then(mod => (0, mod['authenticate'])(...args)),\n  '4cce0840ac9b329a49dfe73eb7178760406da35a': (...args) => Promise.resolve(require('ACTIONS_MODULE0')).then(mod => (0, mod['getMissingKeys'])(...args)),\n  '5afba243169d2b28df328e67fd9fa4b4a9d73fa8': (...args) => Promise.resolve(require('ACTIONS_MODULE2')).then(mod => (0, mod['$$ACTION_0'])(...args)),\n  '5e03bcf849e13ca19473aba42d365d04b06cc25f': (...args) => Promise.resolve(require('ACTIONS_MODULE0')).then(mod => (0, mod['clearChats'])(...args)),\n  '6ca9c22386c40a18919c3de1ab9497503920cb02': (...args) => Promise.resolve(require('ACTIONS_MODULE0')).then(mod => (0, mod['getChats'])(...args)),\n  '718cbc29b764923891ed4b7989778bae0bcf4d5b': (...args) => Promise.resolve(require('ACTIONS_MODULE0')).then(mod => (0, mod['refreshHistory'])(...args)),\n  'a674c41a350baa5001122d5ba478d2fd701855d6': (...args) => Promise.resolve(require('ACTIONS_MODULE3')).then(mod => (0, mod['$$ACTION_4'])(...args)),\n  'a8bbe34e13a85554c86edd279e11a5d47f9ac99f': (...args) => Promise.resolve(require('ACTIONS_MODULE0')).then(mod => (0, mod['shareChat'])(...args)),\n  'ab97caf8205be2cafa5e15f7d14d3b611771b349': (...args) => Promise.resolve(require('ACTIONS_MODULE3')).then(mod => (0, mod['$$ACTION_0'])(...args)),\n  'b9866039bc2be50317d38a6877bc3db70570090d': (...args) => Promise.resolve(require('ACTIONS_MODULE0')).then(mod => (0, mod['saveChat'])(...args)),\n  'c81dca8bce6e1732291725afec824719d23bcae3': (...args) => Promise.resolve(require('ACTIONS_MODULE4')).then(mod => (0, mod['$$ACTION_0'])(...args)),\n  'c8fa3317f36f19ea4d0892b9476f0b602c0a04d0': (...args) => Promise.resolve(require('ACTIONS_MODULE3')).then(mod => (0, mod['$$ACTION_1'])(...args)),\n  'c9d0a5a7cbcec3e236840f2cbe72dd889bdf72b8': (...args) => Promise.resolve(require('ACTIONS_MODULE3')).then(mod => (0, mod['$$ACTION_2'])(...args)),\n  'd5acf6a4dfbe80c4e6e05dcee9d7efa1779e6793': (...args) => Promise.resolve(require('ACTIONS_MODULE3')).then(mod => (0, mod['$$ACTION_3'])(...args)),\n  'ebc79be7431569f619b8d3c6ffab40a5718aa134': (...args) => Promise.resolve(require('ACTIONS_MODULE1')).then(mod => (0, mod['getUser'])(...args)),\n  'f1a7cb54f3fd619d4be5d2b973bfd46453125cb6': (...args) => Promise.resolve(require('ACTIONS_MODULE0')).then(mod => (0, mod['getSharedChat'])(...args)),\n});"],"names":[],"mappings":"AAAA,2BAA2B;IACzB,4CAA4C,CAAC,GAAG,OAAS,QAAQ,OAAO,2EAA6B,IAAI,CAAC,CAAA,MAAO,CAAC,GAAG,GAAG,CAAC,UAAU,KAAK;IACxI,4CAA4C,CAAC,GAAG,OAAS,QAAQ,OAAO,2EAA6B,IAAI,CAAC,CAAA,MAAO,CAAC,GAAG,GAAG,CAAC,aAAa,KAAK;IAC3I,4CAA4C,CAAC,GAAG,OAAS,QAAQ,OAAO,iFAA6B,IAAI,CAAC,CAAA,MAAO,CAAC,GAAG,GAAG,CAAC,eAAe,KAAK;IAC7I,4CAA4C,CAAC,GAAG,OAAS,QAAQ,OAAO,2EAA6B,IAAI,CAAC,CAAA,MAAO,CAAC,GAAG,GAAG,CAAC,iBAAiB,KAAK;IAC/I,4CAA4C,CAAC,GAAG,OAAS,QAAQ,OAAO,gPAA6B,IAAI,CAAC,CAAA,MAAO,CAAC,GAAG,GAAG,CAAC,aAAa,KAAK;IAC3I,4CAA4C,CAAC,GAAG,OAAS,QAAQ,OAAO,2EAA6B,IAAI,CAAC,CAAA,MAAO,CAAC,GAAG,GAAG,CAAC,aAAa,KAAK;IAC3I,4CAA4C,CAAC,GAAG,OAAS,QAAQ,OAAO,2EAA6B,IAAI,CAAC,CAAA,MAAO,CAAC,GAAG,GAAG,CAAC,WAAW,KAAK;IACzI,4CAA4C,CAAC,GAAG,OAAS,QAAQ,OAAO,2EAA6B,IAAI,CAAC,CAAA,MAAO,CAAC,GAAG,GAAG,CAAC,iBAAiB,KAAK;IAC/I,4CAA4C,CAAC,GAAG,OAAS,QAAQ,OAAO,iFAA6B,IAAI,CAAC,CAAA,MAAO,CAAC,GAAG,GAAG,CAAC,aAAa,KAAK;IAC3I,4CAA4C,CAAC,GAAG,OAAS,QAAQ,OAAO,2EAA6B,IAAI,CAAC,CAAA,MAAO,CAAC,GAAG,GAAG,CAAC,YAAY,KAAK;IAC1I,4CAA4C,CAAC,GAAG,OAAS,QAAQ,OAAO,iFAA6B,IAAI,CAAC,CAAA,MAAO,CAAC,GAAG,GAAG,CAAC,aAAa,KAAK;IAC3I,4CAA4C,CAAC,GAAG,OAAS,QAAQ,OAAO,2EAA6B,IAAI,CAAC,CAAA,MAAO,CAAC,GAAG,GAAG,CAAC,WAAW,KAAK;IACzI,4CAA4C,CAAC,GAAG,OAAS,QAAQ,OAAO,qFAA6B,IAAI,CAAC,CAAA,MAAO,CAAC,GAAG,GAAG,CAAC,aAAa,KAAK;IAC3I,4CAA4C,CAAC,GAAG,OAAS,QAAQ,OAAO,iFAA6B,IAAI,CAAC,CAAA,MAAO,CAAC,GAAG,GAAG,CAAC,aAAa,KAAK;IAC3I,4CAA4C,CAAC,GAAG,OAAS,QAAQ,OAAO,iFAA6B,IAAI,CAAC,CAAA,MAAO,CAAC,GAAG,GAAG,CAAC,aAAa,KAAK;IAC3I,4CAA4C,CAAC,GAAG,OAAS,QAAQ,OAAO,iFAA6B,IAAI,CAAC,CAAA,MAAO,CAAC,GAAG,GAAG,CAAC,aAAa,KAAK;IAC3I,4CAA4C,CAAC,GAAG,OAAS,QAAQ,OAAO,iFAA6B,IAAI,CAAC,CAAA,MAAO,CAAC,GAAG,GAAG,CAAC,UAAU,KAAK;IACxI,4CAA4C,CAAC,GAAG,OAAS,QAAQ,OAAO,2EAA6B,IAAI,CAAC,CAAA,MAAO,CAAC,GAAG,GAAG,CAAC,gBAAgB,KAAK;AAChJ"}},
    {"offset": {"line": 2209, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}